/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/js/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/rubiks-cube-solver/lib/index.es6.js":
/*!**********************************************************!*\
  !*** ./node_modules/rubiks-cube-solver/lib/index.es6.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 33);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_gl_vec3_cross__ = __webpack_require__(12);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_gl_vec3_cross___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_gl_vec3_cross__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__models_Face__ = __webpack_require__(14);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__models_Vector__ = __webpack_require__(4);\n\n\n\n\n// maps each face with the notation for their middle moves\nconst _middlesMatchingFace = {\n\tf: 's',\n\tr: 'mprime',\n\tu: 'eprime',\n\td: 'e',\n\tl: 'm',\n\tb: 'sprime'\n};\n\n/**\n * @param {string} move - The notation of a move, e.g. rPrime.\n * @return {string}\n */\nconst getFaceOfMove = (move) => {\n\tif (typeof move !== 'string') {\n\t\tthrow new TypeError('move must be a string');\n\t}\n\n\tlet faceLetter = move[0].toLowerCase();\n\n\tif (faceLetter === 'f') return 'front';\n\tif (faceLetter === 'r') return 'right';\n\tif (faceLetter === 'u') return 'up';\n\tif (faceLetter === 'd') return 'down';\n\tif (faceLetter === 'l') return 'left';\n\tif (faceLetter === 'b') return 'back';\n};\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = getFaceOfMove;\n\n\n/**\n * Almost useless. Almost.\n * @param {string} face - The string identifying a face.\n * @return {string}\n */\nconst getMoveOfFace = (face) => {\n\tif (typeof face !== 'string') {\n\t\tthrow new TypeError('face must be a string');\n\t}\n\n\tface = face.toLowerCase();\n\n\tif (!['front', 'right', 'up', 'down', 'left', 'back'].includes(face)) {\n\t\tthrow new Error(`${face} is not valid face`);\n\t}\n\n\treturn face[0];\n};\n/* harmony export (immutable) */ __webpack_exports__[\"f\"] = getMoveOfFace;\n\n\nconst getMiddleMatchingFace = (face) => {\n\tface = face.toLowerCase()[0];\n\treturn _middlesMatchingFace[face];\n};\n/* harmony export (immutable) */ __webpack_exports__[\"g\"] = getMiddleMatchingFace;\n\n\nconst getFaceMatchingMiddle = (middle) => {\n\tmiddle = middle.toLowerCase();\n\n\tfor (let face of Object.keys(_middlesMatchingFace)) {\n\t\tlet testMiddle = _middlesMatchingFace[face];\n\t\tif (middle === testMiddle) {\n\t\t\treturn face;\n\t\t}\n\t}\n};\n/* unused harmony export getFaceMatchingMiddle */\n\n\n/**\n * @param {string|array} notations - The move notation.\n * @param {object} options - Move options.\n * @prop {boolean} options.upperCase - Turn all moves to upper case (i.e. no \"double\" moves).\n *\n * @return {string|array} -- whichever was initially given.\n */\nconst transformNotations = (notations, options = {}) => {\n\tlet normalized = normalizeNotations(notations);\n\n\tif (options.upperCase) {\n\t\tnormalized = normalized.map(n => n[0].toUpperCase() + n.slice(1));\n\t}\n\n\tif (options.orientation) {\n\t\tnormalized = orientMoves(normalized, options.orientation);\n\t}\n\n\tif (options.reverse) {\n\t\tnormalized = _reverseNotations(normalized);\n\t}\n\n\treturn typeof notations === 'string' ? normalized.join(' ') : normalized;\n};\n/* harmony export (immutable) */ __webpack_exports__[\"d\"] = transformNotations;\n\n\n/**\n * @param {array|string} notations - The notations to noramlize.\n * @return {array}\n */\nconst normalizeNotations = (notations) => {\n\tif (typeof notations === 'string') {\n\t\tnotations = notations.split(' ');\n\t}\n\n\tnotations = notations.filter(notation => notation !== '');\n\n\treturn notations.map(notation => {\n\t\tlet isPrime = notation.toLowerCase().includes('prime');\n\t\tlet isDouble = notation.includes('2');\n\n\t\tnotation = notation[0];\n\n\t\tif (isDouble) notation = notation[0] + '2';\n\t\telse if (isPrime) notation = notation + 'prime';\n\n\t\treturn notation;\n\t});\n};\n/* harmony export (immutable) */ __webpack_exports__[\"h\"] = normalizeNotations;\n\n\n/**\n * Finds the direction from an origin face to a target face. The origin face\n * will be oriented so that it becomes FRONT. An orientation object must be\n * provided that specifies any of these faces (exclusively): TOP, RIGHT, DOWN,\n * LEFT.\n * If FRONT or BACK is provided along with one of those faces, it will be\n * ignored. If FRONT or BACK is the only face provided, the orientation is\n * ambiguous and an error will be thrown.\n *\n * Example:\n * getDirectionFromFaces('back', 'up', { down: 'right' })\n * Step 1) orient the BACK face so that it becomes FRONT.\n * Step 2) orient the DOWN face so that it becomes RIGHT.\n * Step 3) Find the direction from BACK (now FRONT) to UP (now LEFT).\n * Step 4) Returns 'left'.\n *\n * @param {string} origin - The origin face.\n * @param {string} target - The target face.\n * @param {object} orientation - The object that specifies the cube orientation.\n * @return {string|number}\n */\nconst getDirectionFromFaces = (origin, target, orientation) => {\n\torientation = _toLowerCase(orientation);\n\torientation = _prepOrientationForDirection(orientation, origin);\n\n\tlet fromFace = new __WEBPACK_IMPORTED_MODULE_1__models_Face__[\"a\" /* Face */](origin);\n\tlet toFace = new __WEBPACK_IMPORTED_MODULE_1__models_Face__[\"a\" /* Face */](target);\n\n\tlet rotations = _getRotationsForOrientation(orientation);\n\t_rotateFacesByRotations([fromFace, toFace], rotations);\n\n\tlet axis = new __WEBPACK_IMPORTED_MODULE_2__models_Vector__[\"a\" /* Vector */](__WEBPACK_IMPORTED_MODULE_0_gl_vec3_cross___default()([], fromFace.normal(), toFace.normal())).getAxis();\n\tlet direction = __WEBPACK_IMPORTED_MODULE_2__models_Vector__[\"a\" /* Vector */].getAngle(fromFace.normal(), toFace.normal());\n\n\tif (axis === 'x' && direction > 0) return 'down';\n\tif (axis === 'x' && direction < 0) return 'up';\n\tif (axis === 'y' && direction > 0) return 'right';\n\tif (axis === 'y' && direction < 0) return 'left';\n\n\tif (direction === 0) {\n\t\treturn 'front';\n\t} else if (direction === Math.PI) {\n\t\treturn 'back';\n\t}\n};\n/* harmony export (immutable) */ __webpack_exports__[\"c\"] = getDirectionFromFaces;\n\n\n/**\n * See `getDirectionFromFaces`. Almost identical, but instead of finding a\n * direction from an origin face and target face, this finds a target face from\n * an origin face and direction.\n * @param {string} origin - The origin face.\n * @param {string} direction - The direction.\n * @param {object} orientation - The orientation object.\n * @return {string}\n */\nconst getFaceFromDirection = (origin, direction, orientation) => {\n\torientation = _toLowerCase(orientation);\n\torientation = _prepOrientationForDirection(orientation, origin);\n\n\tlet fromFace = new __WEBPACK_IMPORTED_MODULE_1__models_Face__[\"a\" /* Face */](origin);\n\n\tlet rotations = _getRotationsForOrientation(orientation);\n\t_rotateFacesByRotations([fromFace], rotations);\n\n\tlet directionFace = new __WEBPACK_IMPORTED_MODULE_1__models_Face__[\"a\" /* Face */](direction);\n\tlet { axis, angle } = __WEBPACK_IMPORTED_MODULE_2__models_Vector__[\"a\" /* Vector */].getRotationFromNormals(fromFace.normal(), directionFace.normal());\n\tfromFace.rotate(axis, angle);\n\n\t// at this point fromFace is now the target face, but we still need to revert\n\t// the orientation to return the correct string\n\tlet reversedRotations = rotations.map(rotation => __WEBPACK_IMPORTED_MODULE_2__models_Vector__[\"a\" /* Vector */].reverseRotation(rotation)).reverse();\n\t_rotateFacesByRotations([fromFace], reversedRotations);\n\treturn fromFace.toString();\n};\n/* harmony export (immutable) */ __webpack_exports__[\"e\"] = getFaceFromDirection;\n\n\n/**\n * Finds a move that rotates the given face around its normal, by the angle\n * described by normal1 -> normal2.\n * @param {string} face - The face to rotate.\n * @param {string} from - The origin face.\n * @param {string} to - The target face.\n * @return {string}\n */\nconst getRotationFromTo = (face, from, to) => {\n\tconst rotationFace = new __WEBPACK_IMPORTED_MODULE_1__models_Face__[\"a\" /* Face */](face);\n\tconst fromFace = new __WEBPACK_IMPORTED_MODULE_1__models_Face__[\"a\" /* Face */](from);\n\tconst toFace = new __WEBPACK_IMPORTED_MODULE_1__models_Face__[\"a\" /* Face */](to);\n\n\tlet rotationAxis = rotationFace.vector.getAxis();\n\tlet [fromAxis, toAxis] = [fromFace.vector.getAxis(), toFace.vector.getAxis()];\n\n\tif ([fromAxis.toLowerCase(), toAxis.toLowerCase()].includes(rotationAxis.toLowerCase())) {\n\t\tthrow new Error(`moving ${rotationFace} from ${fromFace} to ${toFace} is not possible.`);\n\t}\n\n\tlet move = getMoveOfFace(face).toUpperCase();\n\tlet angle = __WEBPACK_IMPORTED_MODULE_2__models_Vector__[\"a\" /* Vector */].getAngle(fromFace.normal(), toFace.normal());\n\tif (rotationFace.vector.getMagnitude() < 0) {\n\t\tangle *= -1;\n\t}\n\n\tif (angle === 0) {\n\t\treturn '';\n\t} else if (Math.abs(angle) === Math.PI) {\n\t\treturn `${move} ${move}`;\n\t} else if (angle < 0) {\n\t\treturn `${move}`;\n\t} else if (angle > 0) {\n\t\treturn `${move}Prime`;\n\t}\n};\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = getRotationFromTo;\n\n\n/**\n * Returns an array of transformed notations so that if done when the cube's\n * orientation is default (FRONT face is FRONT, RIGHT face is RIGHT, etc.), the\n * moves will have the same effect as performing the given notations on a cube\n * oriented by the specified orientation.\n *\n * Examples:\n * orientMoves(['R', 'U'], { front: 'front', up: 'up' })      === ['R', 'U']\n * orientMoves(['R', 'U'], { front: 'front', down: 'right' }) === ['U', 'L']\n * orientMoves(['R', 'U', 'LPrime', 'D'], { up: 'back', right: 'down' }) === ['D', 'B', 'UPrime', 'F']\n *\n * @param {array} notations - An array of notation strings.\n * @param {object} orientation - The orientation object.\n */\nconst orientMoves = (notations, orientation) => {\n\torientation = _toLowerCase(orientation);\n\tlet rotations = _getRotationsForOrientation(orientation);\n\trotations.reverse().map(rotation => __WEBPACK_IMPORTED_MODULE_2__models_Vector__[\"a\" /* Vector */].reverseRotation(rotation));\n\n\treturn notations.map(notation => {\n\t\tlet isPrime = notation.toLowerCase().includes('prime');\n\t\tlet isDouble = notation.includes('2');\n\t\tlet isWithMiddle = notation[0] === notation[0].toLowerCase();\n\t\tlet isMiddle = ['m', 'e', 's'].includes(notation[0].toLowerCase());\n\n\t\tif (isDouble) {\n\t\t\tnotation = notation.replace('2', '');\n\t\t}\n\n\t\tlet face;\n\n\t\tif (isMiddle) {\n\t\t\tlet faceStr = getFaceOfMove(getFaceMatchingMiddle(notation));\n\t\t\tface = new __WEBPACK_IMPORTED_MODULE_1__models_Face__[\"a\" /* Face */](faceStr);\n\t\t} else {\n\t\t\tlet faceStr = getFaceOfMove(notation[0]);\n\t\t\tface = new __WEBPACK_IMPORTED_MODULE_1__models_Face__[\"a\" /* Face */](faceStr);\n\t\t}\n\n\t\t_rotateFacesByRotations([face], rotations);\n\n\t\tlet newNotation; // this will always be lower case\n\n\t\tif (isMiddle) {\n\t\t\tnewNotation = getMiddleMatchingFace(face.toString());\n\t\t} else {\n\t\t\tnewNotation = face.toString()[0];\n\t\t}\n\n\t\tif (!isWithMiddle) newNotation = newNotation.toUpperCase();\n\t\tif (isDouble) newNotation = newNotation + '2';\n\t\tif (isPrime && !isMiddle) newNotation += 'prime';\n\n\t\treturn newNotation;\n\t});\n};\n/* unused harmony export orientMoves */\n\n\n//-----------------\n// Helper functions\n//-----------------\n\n/**\n * Returns an object with all keys and values lowercased. Assumes all keys and\n * values are strings.\n * @param {object} object - The object to map.\n */\nfunction _toLowerCase(object) {\n\tlet ret = {};\n\tObject.keys(object).forEach(key => {\n\t\tret[key.toLowerCase()] = object[key].toLowerCase();\n\t});\n\treturn ret;\n}\n\n/**\n * This function is specificly for `getDirectionFromFaces` and\n * `getFaceFromDirection`. It removes all keys that are either 'front' or 'back'\n * and sets the given front face to orientation.front.\n * @param {object} orientation - The orientation object.\n * @param {string} front - The face to set as front.\n */\nfunction _prepOrientationForDirection(orientation, front) {\n\tlet keys = Object.keys(orientation);\n\n\tif (keys.length <= 1 && ['front', 'back'].includes(keys[0])) {\n\t\tthrow new Error(`Orientation object \"${orientation}\" is ambiguous. Please specify one of these faces: \"up\", \"right\", \"down\", \"left\"`);\n\t}\n\n\t// remove \"front\" and \"back\" from provided orientation object\n\tlet temp = orientation;\n\torientation = {};\n\n\tkeys.forEach(key => {\n\t\tif (['front', 'back'].includes(key)) {\n\t\t\treturn;\n\t\t}\n\t\torientation[key] = temp[key];\n\t});\n\n\torientation.front = front.toLowerCase();\n\n\treturn orientation;\n}\n\n/**\n * @param {object} orientation - The orientation object.\n * @return {array}\n */\nfunction _getRotationsForOrientation(orientation) {\n\tif (Object.keys(orientation) <= 1) {\n\t\tthrow new Error(`Orientation object \"${orientation}\" is ambiguous. Please specify 2 faces.`);\n\t}\n\n\tlet keys = Object.keys(orientation);\n\tlet origins = keys.map(key => new __WEBPACK_IMPORTED_MODULE_1__models_Face__[\"a\" /* Face */](orientation[key]));\n\tlet targets = keys.map(key => new __WEBPACK_IMPORTED_MODULE_1__models_Face__[\"a\" /* Face */](key));\n\n\t// perform the first rotation, and save it\n\tlet rotation1 = __WEBPACK_IMPORTED_MODULE_2__models_Vector__[\"a\" /* Vector */].getRotationFromNormals(\n\t\torigins[0].normal(),\n\t\torigins[0].orientTo(targets[0]).normal()\n\t);\n\n\t// perform the first rotation on the second origin face\n\torigins[1].rotate(rotation1.axis, rotation1.angle);\n\n\t// peform the second rotation, and save it\n\tlet rotation2 = __WEBPACK_IMPORTED_MODULE_2__models_Vector__[\"a\" /* Vector */].getRotationFromNormals(\n\t\torigins[1].normal(),\n\t\torigins[1].orientTo(targets[1]).normal()\n\t);\n\n\t// if the rotation angle is PI, there are 3 possible axes that can perform the\n\t// rotation. however only one axis will perform the rotation while keeping\n\t// the first origin face on the target. this axis is the same as the origin\n\t// face's normal.\n\tif (Math.abs(rotation2.angle) === Math.PI) {\n\t\tlet rotation2Axis = new __WEBPACK_IMPORTED_MODULE_1__models_Face__[\"a\" /* Face */](keys[0]).vector.getAxis();\n\t\trotation2.axis = rotation2Axis;\n\t}\n\n\treturn [rotation1, rotation2];\n}\n\n/**\n * @param {array} - Array of Face objects to rotate.\n * @param {array} - Array of rotations to apply to faces.\n * @return {null}\n */\nfunction _rotateFacesByRotations(faces, rotations) {\n\tfor (let face of faces) {\n\t\tfor (let rotation of rotations) {\n\t\t\tface.rotate(rotation.axis, rotation.angle);\n\t\t}\n\t}\n}\n\n/**\n * @param {array} notations\n * @return {array}\n */\nfunction _reverseNotations(notations) {\n\tconst reversed = [];\n\n\tfor (let notation of notations) {\n\t\tlet isPrime = notation.includes('prime');\n\t\tnotation = isPrime ? notation[0] : notation[0] + 'prime';\n\t\treversed.push(notation);\n\t}\n\n\treturn typeof moves === 'string' ? reversed.join(' ') : reversed;\n}\n\n/* unused harmony default export */ var _unused_webpack_default_export = ({\n\tgetFaceOfMove,\n\tgetMoveOfFace,\n\tgetMiddleMatchingFace,\n\tgetFaceMatchingMiddle,\n\ttransformNotations,\n\tnormalizeNotations,\n\tgetDirectionFromFaces,\n\tgetRotationFromTo,\n\tgetFaceFromDirection,\n\torientMoves\n});\n\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return RubiksCube; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Cubie__ = __webpack_require__(6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__algorithm_shortener__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils__ = __webpack_require__(0);\n\n\n\n\nconst SOLVED_STATE = 'fffffffffrrrrrrrrruuuuuuuuudddddddddlllllllllbbbbbbbbb';\n\nclass RubiksCube {\n\t/**\n\t * Factory method. Returns an instance of a solved Rubiks Cube.\n\t */\n\tstatic Solved() {\n\t\treturn new RubiksCube(SOLVED_STATE);\n\t}\n\n\t/**\n\t * Factory method.\n\t * @param {string|array} moves\n\t */\n\tstatic FromMoves(moves) {\n\t\tconst cube = RubiksCube.Solved();\n\t\tcube.move(moves);\n\t\treturn cube;\n\t}\n\n\t/**\n\t * Factory method. Returns an instance of a scrambled Rubiks Cube.\n\t */\n\tstatic Scrambled() {\n\t\tlet cube = RubiksCube.Solved();\n\t\tlet randomMoves = RubiksCube.getRandomMoves(25);\n\t\tcube.move(randomMoves);\n\n\t\treturn cube;\n\t}\n\n\t/**\n\t * @param {string|array} notations - The list of moves to reverse.\n\t * @return {string|array} -- whichever was initially given.\n\t */\n\tstatic reverseMoves(moves) {\n\t\treturn RubiksCube.transformMoves(moves, { reverse: true });\n\t}\n\n\t/**\n\t * @param {string|array} moves - The moves to transform;\n\t * @param {object} options\n\t * @prop {boolean} options.upperCase - Turn lowercase moves into uppercase.\n\t * @prop {object} options.orientation - An object describing the orientation\n\t * from which to makes the moves. See src/js/utils#orientMoves.\n\t *\n\t * @return {string|array} -- whichever was initially given.\n\t */\n\tstatic transformMoves(moves, options = {}) {\n\t\treturn __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"d\" /* transformNotations */])(moves, options);\n\t}\n\n\tstatic getRandomMoves(length = 25) {\n\t\tlet randomMoves = [];\n\t\tlet totalMoves = [\n\t\t\t'F',\n\t\t\t'Fprime',\n\t\t\t'R',\n\t\t\t'Rprime',\n\t\t\t'U',\n\t\t\t'Uprime',\n\t\t\t'D',\n\t\t\t'Dprime',\n\t\t\t'L',\n\t\t\t'Lprime',\n\t\t\t'B',\n\t\t\t'Bprime'\n\t\t];\n\n\t\twhile (randomMoves.length < length) {\n\t\t\tfor (let i = 0; i < length - randomMoves.length; i++) {\n\t\t\t\tlet idx = ~~(Math.random() * totalMoves.length);\n\t\t\t\trandomMoves.push(totalMoves[idx]);\n\t\t\t}\n\n\t\t\trandomMoves = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__algorithm_shortener__[\"a\" /* algorithmShortener */])(randomMoves).split(' ');\n\t\t}\n\n\t\treturn randomMoves.join(' ');\n\t}\n\n\t/**\n\t * @param {string} cubeState - The string representing the Rubik's Cube.\n\t *\n\t * The cube state are represented as:\n\t * 'FFFFFFFFFRRRRRRRRRUUUUUUUUUDDDDDDDDDLLLLLLLLLBBBBBBBBB'\n\t *\n\t * where:\n\t * F stands for the FRONT COLOR\n\t * R stands for the RIGHT COLOR\n\t * U stands for the UP COLOR\n\t * D stands for the DOWN COLOR\n\t * L stands for the LEFT COLOR\n\t * B stands for the BACK COLOR\n\t *\n\t * and the faces are given in the order of:\n\t * FRONT, RIGHT, UP, DOWN, LEFT, BACK\n\t *\n\t * The order of each color per face is ordered by starting from the top left\n\t * corner and moving to the bottom right, as if reading lines of text.\n\t *\n\t * See this example: http://2.bp.blogspot.com/_XQ7FznWBAYE/S9Sbric1KNI/AAAAAAAAAFs/wGAb_LcSOwo/s1600/rubik.png\n\t */\n\tconstructor(cubeState) {\n\t\tif (cubeState.length !== 9 * 6) {\n\t\t\tthrow new Error('Wrong number of colors provided');\n\t\t}\n\n\t\tthis._notationToRotation = {\n\t\t\tf: { axis: 'z', mag: -1 },\n\t\t\tr: { axis: 'x', mag: -1 },\n\t\t\tu: { axis: 'y', mag: -1 },\n\t\t\td: { axis: 'y', mag: 1 },\n\t\t\tl: { axis: 'x', mag: 1 },\n\t\t\tb: { axis: 'z', mag: 1 },\n\t\t\tm: { axis: 'x', mag: 1 },\n\t\t\te: { axis: 'y', mag: 1 },\n\t\t\ts: { axis: 'z', mag: -1 }\n\t\t};\n\n\t\tthis._build(cubeState);\n\t}\n\n\t/**\n\t * Grab all the cubes on a given face, and return them in order from top left\n\t * to bottom right.\n\t * @param {string} face - The face to grab.\n\t * @return {array}\n\t */\n\tgetFace(face) {\n\t\tif (typeof face !== 'string') {\n\t\t\tthrow new Error(`\"face\" must be a string (received: ${face})`);\n\t\t}\n\n\t\tface = face.toLowerCase()[0];\n\n\t\t// The 3D position of cubies and the way they're ordered on each face\n\t\t// do not play nicely. Below is a shitty way to reconcile the two.\n\t\t// The way the cubies are sorted depends on the row and column they\n\t\t// occupy on their face. Cubies on a higher row will have a lower sorting\n\t\t// index, but rows are not always denoted by cubies' y position, and\n\t\t// \"higher rows\" do not always mean \"higher axis values\".\n\n\t\tlet row, col, rowOrder, colOrder;\n\t\tlet cubies;\n\n\t\t// grab correct cubies\n\t\tif (face === 'f') {\n\t\t\t[row, col, rowOrder, colOrder] = ['Y', 'X', -1, 1];\n\t\t\tcubies = this._cubies.filter(cubie => cubie.getZ() === 1);\n\t\t} else if (face === 'r') {\n\t\t\t[row, col, rowOrder, colOrder] = ['Y', 'Z', -1, -1];\n\t\t\tcubies = this._cubies.filter(cubie => cubie.getX() === 1);\n\t\t} else if (face === 'u') {\n\t\t\t[row, col, rowOrder, colOrder] = ['Z', 'X', 1, 1];\n\t\t\tcubies = this._cubies.filter(cubie => cubie.getY() === 1);\n\t\t} else if (face === 'd') {\n\t\t\t[row, col, rowOrder, colOrder] = ['Z', 'X', -1, 1];\n\t\t\tcubies = this._cubies.filter(cubie => cubie.getY() === -1);\n\t\t} else if (face === 'l') {\n\t\t\t[row, col, rowOrder, colOrder] = ['Y', 'Z', -1, 1];\n\t\t\tcubies = this._cubies.filter(cubie => cubie.getX() === -1);\n\t\t} else if (face === 'b') {\n\t\t\t[row, col, rowOrder, colOrder] = ['Y', 'X', -1, -1];\n\t\t\tcubies = this._cubies.filter(cubie => cubie.getZ() === -1);\n\t\t} else if (['m', 'e', 's'].includes(face)) {\n\t\t\treturn this._getMiddleCubiesForMove(face);\n\t\t}\n\n\t\t// order cubies from top left to bottom right\n\t\treturn cubies.sort((first, second) => {\n\t\t\tlet firstCubieRow = first[`get${row}`]() * rowOrder;\n\t\t\tlet firstCubieCol = first[`get${col}`]() * colOrder;\n\n\t\t\tlet secondCubieRow = second[`get${row}`]() * rowOrder;\n\t\t\tlet secondCubieCol = second[`get${col}`]() * colOrder;\n\n\t\t\tif (firstCubieRow < secondCubieRow) {\n\t\t\t\treturn -1;\n\t\t\t} else if (firstCubieRow > secondCubieRow) {\n\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t\treturn firstCubieCol < secondCubieCol ? -1 : 1;\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * @param {array} faces - The list of faces the cubie belongs on.\n\t */\n\tgetCubie(faces) {\n\t\treturn this._cubies.find(cubie => {\n\t\t\tif (faces.length != cubie.faces().length) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tfor (let face of faces) {\n\t\t\t\tif (!cubie.faces().includes(face)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t});\n\t}\n\n\t/**\n\t * Finds and returns all cubies with three colors.\n\t * @return {array}\n\t */\n\tcorners() {\n\t\treturn this._cubies.filter(cubie => cubie.isCorner());\n\t}\n\n\t/**\n\t * Finds and returns all cubies with two colors.\n\t * @return {array}\n\t */\n\tedges() {\n\t\treturn this._cubies.filter(cubie => cubie.isEdge());\n\t}\n\n\t/**\n\t * Finds and returns all cubies with one color.\n\t * @return {array}\n\t */\n\tmiddles() {\n\t\treturn this._cubies.filter(cubie => cubie.isMiddle());\n\t}\n\n\t/**\n\t * Gets the rotation axis and magnitude of rotation based on notation.\n\t * Then finds all cubes on the correct face, and rotates them around the\n\t * rotation axis.\n\t * @param {string|array} notations - The move notation.\n\t * @param {object} options - Move options.\n\t * @prop {boolean} options.upperCase - Turn all moves to upper case (i.e. no \"double\" moves).\n\t */\n\tmove(notations, options = {}) {\n\t\tif (typeof notations === 'string') {\n\t\t\tnotations = notations.split(' ');\n\t\t}\n\n\t\tnotations = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"d\" /* transformNotations */])(notations, options);\n\n\t\tfor (let notation of notations) {\n\t\t\tlet move = notation[0];\n\n\t\t\tif (!move) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet isPrime = notation.toLowerCase().includes('prime');\n\t\t\tlet isWithMiddle = move === move.toLowerCase();\n\t\t\tlet isDoubleMove  = notation.includes('2');\n\n\t\t\tlet { axis, mag } = this._getRotationForFace(move);\n\t\t\tlet cubesToRotate = this.getFace(move);\n\n\t\t\tif (isPrime) mag *= -1;\n\t\t\tif (isDoubleMove) mag *= 2;\n\n\t\t\tif (isWithMiddle) {\n\t\t\t\tlet middleMove = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"g\" /* getMiddleMatchingFace */])(move);\n\t\t\t\tlet middleCubies = this._getMiddleCubiesForMove(middleMove);\n\t\t\t\tcubesToRotate = [...cubesToRotate, ...middleCubies];\n\t\t\t}\n\n\t\t\tfor (let cubie of cubesToRotate) {\n\t\t\t\tcubie.rotate(axis, mag);\n\t\t\t}\n\t\t}\n\t}\n\n\tisSolved() {\n\t\treturn this.toString() === SOLVED_STATE;\n\t}\n\n\ttoString() {\n\t\tlet cubeState = '';\n\n\t\tlet faces = ['front', 'right', 'up', 'down', 'left', 'back'];\n\t\tfor (let face of faces) {\n\t\t\tlet cubies = this.getFace(face);\n\t\t\tfor (let cubie of cubies) {\n\t\t\t\tcubeState += cubie.getColorOfFace(face);\n\t\t\t}\n\t\t}\n\n\t\treturn cubeState;\n\t}\n\n\tclone() {\n\t\treturn new RubiksCube(this.toString());\n\t}\n\n\t/**\n\t * Create a \"virtual\" cube, with individual \"cubies\" having a 3D coordinate\n\t * position and 1 or more colors attached to them.\n\t */\n\t_build(cubeState) {\n\t\tthis._cubies = [];\n\t\tthis._populateCube();\n\n\t\tlet parsedColors = this._parseColors(cubeState);\n\n\t\tfor (let face of Object.keys(parsedColors)) {\n\t\t\tlet colors = parsedColors[face];\n\t\t\tthis._colorFace(face, colors);\n\t\t}\n\t}\n\n\t/**\n\t * Populates the \"virtual\" cube with 26 \"empty\" cubies by their position.\n\t * @return {null}\n\t */\n\t_populateCube() {\n\t\tfor (let x = -1; x <= 1; x++) {\n\t\t\tfor (let y = -1; y <= 1; y++) {\n\t\t\t\tfor (let z = -1; z <= 1; z++) {\n\t\t\t\t\t// no cubie in the center of the rubik's cube\n\t\t\t\t\tif (x === 0 && y === 0 && z === 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet cubie = new __WEBPACK_IMPORTED_MODULE_0__Cubie__[\"a\" /* Cubie */]({ position: [x, y, z] });\n\t\t\t\t\tthis._cubies.push(cubie);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @return {object} - A map with faces for keys and colors for values\n\t */\n\t_parseColors(cubeState) {\n\t\tlet faceColors = {\n\t\t\tfront: [],\n\t\t\tright: [],\n\t\t\tup: [],\n\t\t\tdown: [],\n\t\t\tleft: [],\n\t\t\tback: []\n\t\t};\n\n\t\tlet currentFace;\n\n\t\tfor (let i = 0; i < cubeState.length; i++) {\n\t\t\tlet color = cubeState[i];\n\n\t\t\tif (i < 9) {\n\t\t\t\tcurrentFace = 'front';\n\t\t\t} else if (i < 9 * 2) {\n\t\t\t\tcurrentFace = 'right';\n\t\t\t} else if (i < 9 * 3) {\n\t\t\t\tcurrentFace = 'up';\n\t\t\t} else if (i < 9 * 4) {\n\t\t\t\tcurrentFace = 'down';\n\t\t\t} else if (i < 9 * 5) {\n\t\t\t\tcurrentFace = 'left';\n\t\t\t} else {\n\t\t\t\tcurrentFace = 'back';\n\t\t\t}\n\n\t\t\tfaceColors[currentFace].push(color);\n\t\t}\n\n\t\treturn faceColors;\n\t}\n\n\t/**\n\t * @param {array} face - An array of the cubies on the given face.\n\t * @param {array} colors - An array of the colors on the given face.\n\t */\n\t_colorFace(face, colors) {\n\t\tlet cubiesToColor = this.getFace(face);\n\t\tfor (let i = 0; i < colors.length; i++) {\n\t\t\tcubiesToColor[i].colorFace(face, colors[i]);\n\t\t}\n\t}\n\n\t/**\n\t * @return {object} - The the rotation axis and magnitude for the given face.\n\t */\n\t_getRotationForFace(face) {\n\t\tif (typeof face !== 'string') {\n\t\t\tthrow new Error(`\"face\" must be a string (received: ${face})`);\n\t\t}\n\n\t\tface = face.toLowerCase();\n\n\t\treturn {\n\t\t\taxis: this._notationToRotation[face].axis,\n\t\t\tmag: this._notationToRotation[face].mag * Math.PI / 2\n\t\t};\n\t}\n\n\t_getMiddleCubiesForMove(move) {\n\t\tmove = move[0].toLowerCase();\n\n\t\tlet nonMiddles;\n\t\tif (move === 'm') {\n\t\t\tnonMiddles = ['left', 'right'];\n\t\t} else if (move === 'e') {\n\t\t\tnonMiddles = ['up', 'down'];\n\t\t} else if (move === 's') {\n\t\t\tnonMiddles = ['front', 'back'];\n\t\t}\n\n\t\treturn this._cubies.filter(cubie => {\n\t\t\treturn !cubie.hasFace(nonMiddles[0]) && !cubie.hasFace(nonMiddles[1]);\n\t\t});\n\t}\n}\n\n\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return algorithmShortener; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_array_element_combiner__ = __webpack_require__(19);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_array_element_combiner___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_array_element_combiner__);\n\n\nconst parallelMoves = {\n\tF: 'B',\n\tR: 'L',\n\tU: 'D'\n};\n\n/**\n * @param {array|string} notations - The array of move notations.\n * @return {string}\n */\nconst algorithmShortener = (notations) => {\n\tif (typeof notations === 'string') {\n\t\tnotations = notations.split(' ');\n\t}\n\n\tconst options = {\n\t\tcompare(a, b) {\n\t\t\treturn a[0] === b[0];\n\t\t},\n\t\tcombine(a, b) {\n\t\t\tconst aDir = a.includes('2') ? 2 : (a.includes('prime') ? -1 : 1);\n\t\t\tconst bDir = b.includes('2') ? 2 : (b.includes('prime') ? -1 : 1);\n\n\t\t\tlet totalDir = aDir + bDir;\n\n\t\t\tif (totalDir === 4) totalDir = 0;\n\t\t\tif (totalDir === -2) totalDir = 2;\n\t\t\tif (totalDir === 3) totalDir = -1;\n\n\t\t\tif (totalDir === 0) {\n\t\t\t\treturn '';\n\t\t\t}\n\n\t\t\tlet dirString = totalDir === 2 ? '2' : (totalDir === -1 ? 'prime' : '');\n\n\t\t\treturn `${a[0]}${dirString}`;\n\t\t},\n\t\tcancel(value) {\n\t\t\treturn value === '';\n\t\t},\n\t\tignore(a, b) {\n\t\t\treturn (parallelMoves[a[0]] === b[0] || parallelMoves[b[0]] === a[0]);\n\t\t}\n\t};\n\n\treturn __WEBPACK_IMPORTED_MODULE_0_array_element_combiner___default()(notations, options).join(' ');\n};\n\n\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return BaseSolver; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__models_RubiksCube__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils___ = __webpack_require__(0);\n\n\n\nclass BaseSolver {\n\t/**\n\t * Solves the first step following the Fridrich Method: the cross. Solves the\n\t * cross on the UP face by default.\n\t *\n\t * @param {string|RubiksCube} rubiksCube - This can either be a 54-character\n\t * long string representing the cube state (in this case it will have to\n\t * \"build\" another rubik's Cube), or an already built RubiksCube object.\n\t */\n\tconstructor(rubiksCube, options = {}) {\n\t\tthis.cube = typeof rubiksCube === 'string' ? new __WEBPACK_IMPORTED_MODULE_0__models_RubiksCube__[\"a\" /* RubiksCube */](rubiksCube) : rubiksCube;\n\t\tthis.options = options;\n\n\t\tthis.partition = {};\n\t\tthis.partitions = [];\n\t\tthis.totalMoves = [];\n\t\tthis._afterEachCallbacks = [];\n\t}\n\n\t/**\n\t * @param {string|array} notation - A string of move(s) to execute and store.\n\t * @param {object} options - The options to pass to RubiksCube#move.\n\t */\n\tmove(notations, options) {\n\t\tif (typeof notations === 'string') {\n\t\t\tnotations = notations.split(' ');\n\t\t}\n\n\t\tthis.cube.move(notations, options);\n\n\t\t// this step is also in RubiksCube#move, but it is important we do it here\n\t\t// as well. The notations need to be saved to the partition correctly.\n\t\tnotations = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils___[\"d\" /* transformNotations */])(notations, options);\n\n\t\tfor (let notation of notations) {\n\t\t\tthis.totalMoves.push(notation);\n\t\t}\n\t}\n\n\tafterEach(callback) {\n\t\tthis._afterEachCallbacks.push(callback);\n\t}\n\n\t/**\n\t * @param {...*} callbackArgs - The arguments to call the function with.\n\t */\n\t_triggerAfterEach(...callbackArgs) {\n\t\tthis._afterEachCallbacks.forEach(fn => fn(...callbackArgs));\n\t}\n\n\t/**\n\t * Solves the edge and/or corner and returns information about the state\n\t * about them right before they are solved. It's important to construct the\n\t * object in steps for debugging, so that we can still have access to e.g.\n\t * the case number if the solve method fails.\n\t */\n\t_solve(cubies = {}) {\n\n\t\tthis.partition = {};\n\t\tthis.partition.cubies = cubies;\n\n\t\tlet { corner, edge } = cubies;\n\n\t\tthis.partition.caseNumber = this._getCaseNumber({ corner, edge });\n\n\t\tthis._solveCase(this.partition.caseNumber, { corner, edge });\n\t\tthis.partition.moves = this.totalMoves;\n\n\t\tthis.totalMoves = [];\n\n\t\tif (!this._overrideAfterEach) {\n\t\t\tthis._triggerAfterEach(this.partition, this.phase);\n\t\t}\n\n\t\treturn this.partition;\n\t}\n\n\t_solveCase(caseNumber, cubies = {}) {\n\t\tlet { corner, edge } = cubies;\n\t\tthis[`_solveCase${caseNumber}`]({ corner, edge });\n\t}\n}\n\n\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Vector; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_gl_vec3_angle__ = __webpack_require__(22);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_gl_vec3_angle___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_gl_vec3_angle__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_gl_vec3_cross__ = __webpack_require__(12);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_gl_vec3_cross___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_gl_vec3_cross__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_gl_vec3_rotateX__ = __webpack_require__(26);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_gl_vec3_rotateX___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_gl_vec3_rotateX__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_gl_vec3_rotateY__ = __webpack_require__(27);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_gl_vec3_rotateY___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_gl_vec3_rotateY__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_gl_vec3_rotateZ__ = __webpack_require__(28);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_gl_vec3_rotateZ___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_gl_vec3_rotateZ__);\n\n\n\n\n\n\nconst rotate = {\n\tx: __WEBPACK_IMPORTED_MODULE_2_gl_vec3_rotateX___default.a,\n\ty: __WEBPACK_IMPORTED_MODULE_3_gl_vec3_rotateY___default.a,\n\tz: __WEBPACK_IMPORTED_MODULE_4_gl_vec3_rotateZ___default.a\n};\n\nclass Vector {\n\t/**\n\t * Factory method.\n\t * @param {string} vector - Space-deliminated x, y, and z values.\n\t * @return {Vector}\n\t */\n\tstatic FromString(vector) {\n\t\treturn new Vector(vector.split(' ').map(value => parseInt(value)));\n\t}\n\n\t/**\n\t * @param {array} vector1 - Vector 1.\n\t * @param {array} vector2 - Vector 2.\n\t * @return {boolean}\n\t */\n\tstatic areEqual(vector1, vector2) {\n\t\treturn vector1[0] === vector2[0] && vector1[1] === vector2[1] && vector1[2] === vector2[2];\n\t}\n\n\t/**\n\t * Helper method. gl-vec3's angle function always returns positive but in many\n\t * cases we want the angle in the direction from one vector to another. To get\n\t * the sign of the angle, cross the two vectors and determine the direction the\n\t * crossed vector, um, directs in. For example, the vector [0, -1, 0] would\n\t * shoot negatively along the y-axis.\n\t *\n\t * @param {array} v1 - Vector 1.\n\t * @param {array} v2 - Vector 2.\n\t * @return {number}\n\t */\n\tstatic getAngle(v1, v2) {\n\t\tlet _angle = __WEBPACK_IMPORTED_MODULE_0_gl_vec3_angle___default()(v1, v2);\n\t\tlet crossVector = __WEBPACK_IMPORTED_MODULE_1_gl_vec3_cross___default()([], v1, v2);\n\t\tlet sign = new Vector(crossVector).getMagnitude();\n\n\t\treturn sign ? _angle * sign : _angle;\n\t}\n\n\t/**\n\t * Finds the rotation axis and angle to get from one normal to another.\n\t * @param {array} normal1 - The from normal.\n\t * @param {array} normal2 - The to normal.\n\t * @return {object} - Stores the rotation axis and angle\n\t */\n\tstatic getRotationFromNormals(normal1, normal2) {\n\t\tlet axis = new Vector(__WEBPACK_IMPORTED_MODULE_1_gl_vec3_cross___default()([], normal1, normal2)).getAxis();\n\t\tlet angle = Vector.getAngle(normal1, normal2);\n\n\t\t// when normal1 is equal to or opposite from normal2, it means 2 things: 1)\n\t\t// the cross axis is undefined and 2) the angle is either 0 or PI. This\n\t\t// means that rotating around the axis parallel to normal1 will not result\n\t\t// in any change, while rotating around either of the other two will work\n\t\t// properly.\n\t\tif (!axis) {\n\t\t\tlet axes = ['x', 'y', 'z'];\n\t\t\taxes.splice(axes.indexOf(new Vector(normal1).getAxis()), 1);\n\t\t\taxis = axes[0];\n\t\t}\n\n\t\treturn { axis, angle };\n\t}\n\n\t/**\n\t * @param {object} rotation - The rotation to reverse.\n\t * @return {object}\n\t */\n\tstatic reverseRotation(rotation) {\n\t\trotation.angle *= -1;\n\t\treturn rotation;\n\t}\n\n\t/**\n\t * @param {array} [vector] - Contains x, y, and z values.\n\t */\n\tconstructor(vector) {\n\t\tthis.set(vector);\n\t}\n\n\t/**\n\t * @return {array}\n\t */\n\ttoArray() {\n\t\treturn this.vector;\n\t}\n\n\t/**\n\t * @param {array} vector - The new vector to store.\n\t */\n\tset(vector) {\n\t\tif (typeof vector === 'undefined') {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.vector = vector.map(value => Math.round(value));\n\t}\n\n\t/**\n\t * @param {number} value - The value to store.\n\t */\n\tsetX(value) {\n\t\tthis.vector[0] = value;\n\t}\n\n\t/**\n\t * @param {number} value - The value to store.\n\t */\n\tsetY(value) {\n\t\tthis.vector[1] = value;\n\t}\n\n\t/**\n\t * @param {number} value - The value to store.\n\t */\n\tsetZ(value) {\n\t\tthis.vector[2] = value;\n\t}\n\n\t/**\n\t * @return {number}\n\t */\n\tgetX() {\n\t\treturn this.toArray()[0];\n\t}\n\n\t/**\n\t * @return {number}\n\t */\n\tgetY() {\n\t\treturn this.toArray()[1];\n\t}\n\n\t/**\n\t * @return {number}\n\t */\n\tgetZ() {\n\t\treturn this.toArray()[2];\n\t}\n\n\t/**\n\t * Kind of a flimsy method. If this vector points parallel to an axis, this\n\t * returns true. A hacky way to find this is to count the number of 0's and\n\t * return true if and only if the count is 2.\n\t * @return {boolean}\n\t */\n\tisAxis() {\n\t\tlet count = 0;\n\t\tfor (let value of this.vector) {\n\t\t\tif (value === 0) {\n\t\t\t\tcount += 1;\n\t\t\t}\n\t\t}\n\n\t\treturn count === 2;\n\t}\n\n\t/**\n\t * Kind of a flimsy method. If this vector points parallel to an axis, return\n\t * that axis.\n\t * @return {string}\n\t */\n\tgetAxis() {\n\t\tif (!this.isAxis()) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.vector[0] !== 0) return 'x';\n\t\tif (this.vector[1] !== 0) return 'y';\n\t\tif (this.vector[2] !== 0) return 'z';\n\t}\n\n\t/**\n\t * Kind of a flimsy method. If this vector points parallel to an axis, return\n\t * the magnitude of the value along that axis. (Basically, return whether it\n\t * is positive or negative.)\n\t * @return {number}\n\t */\n\tgetMagnitude() {\n\t\tif (!this.isAxis()) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn this[`get${this.getAxis().toUpperCase()}`]();\n\t}\n\n\t/**\n\t * @param {string} axis - The axis to rotate around.\n\t * @param {number} angle - The angle of rotation.\n\t * @return {Vector}\n\t */\n\trotate(axis, angle) {\n\t\taxis = axis.toLowerCase();\n\n\t\tthis.set(rotate[axis]([], this.vector, [0, 0, 0], angle));\n\t\treturn this;\n\t}\n}\n\n\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return F2LCaseBaseSolver; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__F2LBaseSolver__ = __webpack_require__(15);\n\n\nclass F2LCaseBaseSolver extends __WEBPACK_IMPORTED_MODULE_0__F2LBaseSolver__[\"a\" /* F2LBaseSolver */] {\n\tsolve({ corner, edge }) {\n\t\treturn this._solve({ corner, edge });\n\t}\n}\n\n\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Cubie; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Vector__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Face__ = __webpack_require__(14);\n\n\n\nclass Cubie {\n\t/**\n\t * Factory method. Returns an instance of a cubie identified by the faces it\n\t * sits on.\n\t * @param {array} faces - A list of all the faces this cubie sits on.\n\t */\n\tstatic FromFaces(faces) {\n\t\tlet position = new __WEBPACK_IMPORTED_MODULE_0__Vector__[\"a\" /* Vector */]([0, 0, 0]);\n\t\tlet colorMap = {};\n\n\t\tfor (let face of faces) {\n\t\t\tif (!face) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet temp = new __WEBPACK_IMPORTED_MODULE_1__Face__[\"a\" /* Face */](face);\n\t\t\tlet axis = temp.vector.getAxis().toUpperCase();\n\t\t\tposition[`set${axis}`](temp.vector.getMagnitude());\n\n\t\t\tcolorMap[face.toLowerCase()] = temp.toString()[0].toLowerCase();\n\t\t}\n\n\t\treturn new Cubie({ position: position.toArray(), colorMap });\n\t}\n\n\t/**\n\t * @param {object} [options]\n\t * @param {object} options.position - The cubie's position.\n\t * @param {object} options.colorMap - A map with faces as keys and colors\n\t * as values. For example: { 'front' : 'f' }.\n\t */\n\tconstructor({ position, colorMap = {} }) {\n\t\tthis.position(position);\n\t\tthis.colorMap = {};\n\n\t\tObject.keys(colorMap).forEach(face => {\n\t\t\tlet color = colorMap[face];\n\t\t\tthis.colorFace(face, color);\n\t\t});\n\t}\n\n\t/**\n\t * @return {Cubie}\n\t */\n\tclone() {\n\t\treturn new Cubie({\n\t\t\tposition: this.position(),\n\t\t\tcolorMap: this.colorMap\n\t\t});\n\t}\n\n\t/**\n\t * Getter/setter for the vector position.\n\t * @param {array} [position] - The new position to store.\n\t * @return {array}\n\t */\n\tposition(position) {\n\t\tif (typeof position === 'undefined') {\n\t\t\treturn this.vector ? this.vector.toArray() : this.vector;\n\t\t}\n\n\t\tthis.vector = new __WEBPACK_IMPORTED_MODULE_0__Vector__[\"a\" /* Vector */](position);\n\t}\n\n\t/**\n\t * @return {number}\n\t */\n\tgetX() {\n\t\treturn this.vector.getX();\n\t}\n\n\t/**\n\t * @return {number}\n\t */\n\tgetY() {\n\t\treturn this.vector.getY();\n\t}\n\n\t/**\n\t * @return {number}\n\t */\n\tgetZ() {\n\t\treturn this.vector.getZ();\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tisCorner() {\n\t\treturn Object.keys(this.colorMap).length === 3;\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tisEdge() {\n\t\treturn Object.keys(this.colorMap).length === 2;\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tisMiddle() {\n\t\treturn Object.keys(this.colorMap).length === 1;\n\t}\n\n\t/**\n\t * @return {array}\n\t */\n\tcolors() {\n\t\treturn Object.keys(this.colorMap).map(face => this.colorMap[face]);\n\t}\n\n\t/**\n\t * @param {string} color - Check if the cubie has this color.\n\t * @return {boolean}\n\t */\n\thasColor(color) {\n\t\tcolor = color.toLowerCase();\n\n\t\tfor (let face of Object.keys(this.colorMap)) {\n\t\t\tif (this.colorMap[face] === color) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {string} face - Check if the cubie has this face.\n\t * @return {boolean}\n\t */\n\thasFace(face) {\n\t\tface = face.toLowerCase();\n\t\treturn Object.keys(this.colorMap).includes(face);\n\t}\n\n\t/**\n\t * Sets a color on a given face or normal of a cubie.\n\t * @param {string} face - The face of the cubie we want to set the color on.\n\t * @param {string} color - The color we want to set.\n\t * @return {Cubie}\n\t */\n\tcolorFace(face, color) {\n\t\tface = face.toLowerCase();\n\t\tcolor = color.toLowerCase();\n\n\t\tthis.colorMap[face] = color;\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param {string} face - The color on the face this cubie sits on.\n\t * @return {string}\n\t */\n\tgetColorOfFace(face) {\n\t\tface = face.toLowerCase();\n\n\t\treturn this.colorMap[face];\n\t}\n\n\t/**\n\t * @param {string} color - Find the face that this color sits on.\n\t * @return {string}\n\t */\n\tgetFaceOfColor(color) {\n\t\tcolor = color.toLowerCase();\n\n\t\treturn Object.keys(this.colorMap).find(cubieColor => {\n\t\t\treturn this.colorMap[cubieColor] === color;\n\t\t});\n\t}\n\n\t/**\n\t * Return all the faces this cubie sits on.\n\t * @return {array}\n\t */\n\tfaces() {\n\t\treturn Object.keys(this.colorMap);\n\t}\n\n\t/**\n\t * Rotates the position vector around `axis` by `angle`. Updates the internal\n\t * position vector and the normal-color map.\n\t * @param {string} axis - The axis of rotation.\n\t * @param {number} angle - The magnitude of rotation.\n\t * @return {null}\n\t */\n\trotate(axis, angle) {\n\t\t// update position vector after rotation\n\t\tthis.vector.rotate(axis, angle);\n\n\t\t// update normal-color map\n\t\tlet newMap = {}; // need to completely overwrite the old one\n\n\t\t// go through each normal, rotate it, and assign the new normal the old color\n\t\tfor (let face of Object.keys(this.colorMap)) {\n\t\t\tlet color = this.colorMap[face];\n\t\t\tlet faceModel = new __WEBPACK_IMPORTED_MODULE_1__Face__[\"a\" /* Face */](face);\n\n\t\t\tlet newNormal = faceModel.rotate(axis, angle).normal().join(' ');\n\t\t\tlet newFace = __WEBPACK_IMPORTED_MODULE_1__Face__[\"a\" /* Face */].FromNormal(newNormal).toString().toLowerCase();\n\n\t\t\tnewMap[newFace] = color;\n\t\t}\n\n\t\tthis.colorMap = {};\n\t\tObject.keys(newMap).forEach(face => this.colorFace(face, newMap[face]));\n\t}\n}\n\n\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return CrossSolver; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__BaseSolver__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__models_RubiksCube__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils__ = __webpack_require__(0);\n\n\n\n\nconst CROSS_COLOR = 'u';\nconst R = (moves) => __WEBPACK_IMPORTED_MODULE_1__models_RubiksCube__[\"a\" /* RubiksCube */].reverseMoves(moves);\n\nclass CrossSolver extends __WEBPACK_IMPORTED_MODULE_0__BaseSolver__[\"a\" /* BaseSolver */] {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\n\t\tthis.phase = 'cross';\n\t}\n\n\tsolve() {\n\t\tlet crossEdges = this._getCrossEdges();\n\t\tfor (let edge of crossEdges) {\n\t\t\tlet partition = this._solve({ edge });\n\t\t\tthis.partitions.push(partition);\n\t\t}\n\n\t\treturn this.partitions;\n\t}\n\n\tisSolved() {\n\t\tlet edges = this._getCrossEdges();\n\t\tfor (let edge of edges) {\n\t\t\tif (!this.isEdgeSolved(edge)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tisEdgeSolved(edge) {\n\t\tlet otherColor = edge.colors().find(color => color !== 'u');\n\t\tlet otherFace = edge.faces().find(face => face !== 'up');\n\t\tconst matchesMiddle = otherFace[0] === otherColor;\n\t\tconst isOnCrossFace = edge.getColorOfFace('up') === 'u';\n\n\t\treturn isOnCrossFace && matchesMiddle;\n\t}\n\n\t/**\n\t * Finds all edges that have 'F' as a color.\n\t * @return {array}\n\t */\n\t_getCrossEdges() {\n\t\treturn this.cube.edges().filter(edge => edge.hasColor(CROSS_COLOR));\n\t}\n\n\t/**\n\t * 6 Cases!\n\t * 1) The edge's UP color is on the UP face.\n\t * 2) the edge's UP color is on the DOWN face.\n\t * 3) The edge's UP color is not on the UP or DOWN face and the other color is on the UP face.\n\t * 4) The edge's UP color is not on the UP or DOWN face and the other color is on the DOWN face.\n\t * 5) The edge's UP color is not on the UP or DOWN face and the other color is on the RELATIVE RIGHT face.\n\t * 6) The edge's UP color is not on the UP or DOWN face and the other color is on the RELATIVE LEFT face.\n\t *\n\t * @param {cubie} edge\n\t */\n\t_getCaseNumber({ edge }) {\n\t\tif (edge.getColorOfFace('up') === CROSS_COLOR) {\n\t\t\treturn 1;\n\t\t} else if (edge.getColorOfFace('down') === CROSS_COLOR) {\n\t\t\treturn 2;\n\t\t}\n\n\t\tif (edge.faces().includes('up')) {\n\t\t\treturn 3;\n\t\t} else if (edge.faces().includes('down')) {\n\t\t\treturn 4;\n\t\t}\n\n\t\tlet crossFace = edge.getFaceOfColor(CROSS_COLOR);\n\t\tlet otherFace = edge.getFaceOfColor(edge.colors().find(color => color !== CROSS_COLOR));\n\t\tlet direction = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"c\" /* getDirectionFromFaces */])(crossFace, otherFace, { up: 'up' });\n\n\t\tif (direction === 'right') {\n\t\t\treturn 5;\n\t\t} else if (direction === 'left') {\n\t\t\treturn 6;\n\t\t}\n\t}\n\n\t_solveCase1({ edge }) {\n\t\tif (this.isEdgeSolved(edge)) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet face = edge.faces().find(face => face !== 'up');\n\t\tthis.move(`${face} ${face}`, { upperCase: true });\n\t\tthis._solveCase2({ edge });\n\t}\n\n\t_solveCase2({ edge }) {\n\t\tlet solveMoves = this._case1And2Helper({ edge }, 2);\n\t\tthis.move(solveMoves, { upperCase: true });\n\t}\n\n\t_solveCase3({ edge }) {\n\t\tlet prepMove = this._case3And4Helper({ edge }, 3);\n\t\tthis.move(prepMove, { upperCase: true });\n\t\tthis._solveCase5({ edge });\n\t}\n\n\t_solveCase4({ edge }) {\n\t\tlet prepMove = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"b\" /* getRotationFromTo */])(\n\t\t\t'down',\n\t\t\tedge.getFaceOfColor('u'),\n\t\t\t__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* getFaceOfMove */])(edge.getColorOfFace('down'))\n\t\t);\n\t\tthis.move(prepMove, { upperCase: true });\n\n\t\tlet edgeToMiddle = R(edge.getFaceOfColor('u'));\n\n\t\tthis.move(edgeToMiddle, { upperCase: true });\n\t\tthis._solveCase5({ edge });\n\t}\n\n\t_solveCase5({ edge }) {\n\t\tlet solveMoves = this._case5And6Helper({ edge }, 5);\n\t\tthis.move(solveMoves, { upperCase: true });\n\t}\n\n\t_solveCase6({ edge }) {\n\t\tlet solveMoves = this._case5And6Helper({ edge }, 6);\n\t\tthis.move(solveMoves, { upperCase: true });\n\t}\n\n\t_case1And2Helper({ edge }, caseNum) {\n\t\tlet crossColorFace = caseNum === 1 ? 'up' : 'down';\n\t\tlet currentFace = edge.faces().find(face => face !== crossColorFace);\n\t\tlet targetFace = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* getFaceOfMove */])(edge.getColorOfFace(currentFace));\n\n\t\tlet solveMoves = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"b\" /* getRotationFromTo */])(crossColorFace, currentFace, targetFace);\n\n\t\tif (caseNum === 2) {\n\t\t\tlet edgeToCrossFace = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"f\" /* getMoveOfFace */])(targetFace);\n\t\t\tsolveMoves += ` ${edgeToCrossFace} ${edgeToCrossFace}`;\n\t\t}\n\n\t\treturn solveMoves;\n\t}\n\n\t_case3And4Helper({ edge }, caseNum) {\n\t\tlet prepMove = edge.faces().find(face => !['up', 'down'].includes(face));\n\n\t\tif (caseNum === 4) {\n\t\t\tprepMove = R(prepMove);\n\t\t}\n\n\t\treturn prepMove;\n\t}\n\n\t_case5And6Helper({ edge }, caseNum) {\n\t\tlet otherColor = edge.colors().find(color => color !== 'u');\n\t\tlet currentFace = edge.getFaceOfColor(otherColor);\n\t\tlet targetFace = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* getFaceOfMove */])(otherColor);\n\n\t\tlet prepMove = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"b\" /* getRotationFromTo */])('up', currentFace, targetFace);\n\t\tlet edgeToCrossFace = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"f\" /* getMoveOfFace */])(currentFace);\n\n\t\tif (caseNum === 6) {\n\t\t\tedgeToCrossFace = R(edgeToCrossFace);\n\t\t}\n\n\t\treturn `${R(prepMove)} ${edgeToCrossFace} ${prepMove}`;\n\t}\n\n\t_getPartitionBefore({ edge }) {\n\t\treturn { edge: edge.clone() };\n\t}\n\n\t_getPartitionAfter({ edge }) {\n\t\treturn { edge };\n\t}\n}\n\n\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return F2LSolver; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__models_RubiksCube__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__F2LBaseSolver__ = __webpack_require__(15);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__cases_case_1__ = __webpack_require__(34);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__cases_case_2__ = __webpack_require__(35);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__cases_case_3__ = __webpack_require__(36);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils__ = __webpack_require__(0);\n\n\n\n\n\n\n\nconst R = (moves) => __WEBPACK_IMPORTED_MODULE_0__models_RubiksCube__[\"a\" /* RubiksCube */].reverseMoves(moves);\n\nclass F2LSolver extends __WEBPACK_IMPORTED_MODULE_1__F2LBaseSolver__[\"a\" /* F2LBaseSolver */] {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\n\t\tthis.subCaseOptions = Object.assign(this.options, {\n\t\t\t_overrideAfterEach: true\n\t\t});\n\t}\n\n\tsolve() {\n\t\tthis.partitions = [];\n\n\t\tlet pairs = this.getAllPairs();\n\t\tpairs.forEach(({ corner, edge }) => {\n\t\t\tlet partition = this._solve({ corner, edge });\n\t\t\tthis.partitions.push(partition);\n\t\t});\n\n\t\treturn this.partitions;\n\t}\n\n\tisSolved() {\n\t\tlet pairs = this.getAllPairs();\n\t\tfor (let pair of pairs) {\n\t\t\tif (!this.isPairSolved(pair)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tgetAllPairs() {\n\t\tlet corners = this.cube.corners().filter(corner => {\n\t\t\treturn corner.hasColor('u');\n\t\t});\n\t\tlet edges = this.cube.edges().filter(edge => {\n\t\t\treturn !edge.hasColor('u') && !edge.hasColor('d');\n\t\t});\n\n\t\tlet pairs = [];\n\n\t\tfor (let edge of edges) {\n\t\t\tlet corner = corners.find(corner => {\n\t\t\t\tlet colors = edge.colors();\n\t\t\t\treturn corner.hasColor(colors[0]) && corner.hasColor(colors[1]);\n\t\t\t});\n\n\t\t\tpairs.push({ edge, corner });\n\t\t}\n\n\t\treturn pairs;\n\t}\n\n\t/**\n\t * 4 top level cases: (cross face is UP)\n\t *\n\t * 1) Corner and edge are both on the DOWN face.\n\t * 2) Corner is on the DOWN face and edge is not on DOWN face.\n\t * 3) Corner is on UP face and edge is on DOWN face.\n\t * 4) Corner is on UP face and edge is not on DOWN face.\n\t */\n\t_getCaseNumber({ corner, edge }) {\n\t\tif (corner.faces().includes('down')) {\n\t\t\tif (edge.faces().includes('down')) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (!edge.faces().includes('down') && !edge.faces().includes('up')) {\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t}\n\n\t\tif (corner.faces().includes('up')) {\n\t\t\tif (edge.faces().includes('down')) {\n\t\t\t\treturn 3;\n\t\t\t}\n\t\t\tif (!edge.faces().includes('down') && !edge.faces().includes('up')) {\n\t\t\t\treturn 4;\n\t\t\t}\n\t\t}\n\n\t\tthrow new Error('Could not find a top level F2L case');\n\t}\n\n\t_solveCase1({ corner, edge }) {\n\t\tlet solver = new __WEBPACK_IMPORTED_MODULE_2__cases_case_1__[\"a\" /* Case1Solver */](this.cube, this.subCaseOptions);\n\t\tlet partition = solver.solve({ corner, edge });\n\n\t\tthis.totalMoves = partition.moves;\n\t\tthis.partition.caseNumber = [this.partition.caseNumber, partition.caseNumber];\n\t}\n\n\t_solveCase2({ corner, edge }) {\n\t\tlet solver = new __WEBPACK_IMPORTED_MODULE_3__cases_case_2__[\"a\" /* Case2Solver */](this.cube, this.subCaseOptions);\n\t\tlet partition = solver.solve({ corner, edge });\n\n\t\tthis.totalMoves = partition.moves;\n\t\tthis.partition.caseNumber = [this.partition.caseNumber, partition.caseNumber];\n\t}\n\n\t_solveCase3({ corner, edge }) {\n\t\tlet solver = new __WEBPACK_IMPORTED_MODULE_4__cases_case_3__[\"a\" /* Case3Solver */](this.cube, this.subCaseOptions);\n\t\tlet partition = solver.solve({ corner, edge });\n\n\t\tthis.totalMoves = partition.moves;\n\t\tthis.partition.caseNumber = [this.partition.caseNumber, partition.caseNumber];\n\t}\n\n\t_solveCase4({ corner, edge }) {\n\t\tif (this.isPairSolved({ corner, edge })) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet solver;\n\t\tif (corner.faces().includes(edge.faces()[0]) &&\n\t\t\t\tcorner.faces().includes(edge.faces()[1])) {\n\t\t\tsolver = new __WEBPACK_IMPORTED_MODULE_2__cases_case_1__[\"a\" /* Case1Solver */](this.cube, this.subCaseOptions);\n\t\t} else {\n\t\t\tsolver = new __WEBPACK_IMPORTED_MODULE_3__cases_case_2__[\"a\" /* Case2Solver */](this.cube, this.subCaseOptions);\n\t\t}\n\n\t\tlet faces = corner.faces().filter(face => face !== 'up');\n\t\tlet dir = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__utils__[\"c\" /* getDirectionFromFaces */])(faces[0], faces[1], { up: 'down' });\n\t\tlet cornerRightFace = dir === 'right' ? faces[1] : faces[0];\n\n\t\tthis.move(`${cornerRightFace} D ${R(cornerRightFace)}`, { upperCase: true });\n\n\t\tlet partition = solver.solve({ corner, edge });\n\n\t\tthis.partition.caseNumber = [this.partition.caseNumber, partition.caseNumber];\n\t\tthis.totalMoves = [...this.totalMoves, ...partition.moves];\n\t}\n}\n\n\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return OLLSolver; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__models_RubiksCube__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__BaseSolver__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils__ = __webpack_require__(0);\n\n\n\n\nconst SOLVED_STATE = '00000000';\nconst R = (moves) => __WEBPACK_IMPORTED_MODULE_0__models_RubiksCube__[\"a\" /* RubiksCube */].reverseMoves(moves);\n\nclass OLLSolver extends __WEBPACK_IMPORTED_MODULE_1__BaseSolver__[\"a\" /* BaseSolver */] {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t\tthis.phase = 'oll';\n\n\t\t// orientations in order based on http://badmephisto.com/oll.php, however the\n\t\t// actual algorithms may be different.\n\t\tthis.algorithms = {\n\t\t\t[SOLVED_STATE]: '', // solved state\n\t\t\t'21000110': 'F R U RPrime UPrime FPrime', // 1\n\t\t\t'21211010': 'F R U RPrime UPrime FPrime F R U RPrime UPrime FPrime', // 2\n\t\t\t'10201020': 'R U2 RPrime UPrime R U RPrime UPrime R UPrime RPrime', // 3\n\t\t\t'01112000': 'F U R UPrime RPrime FPrime', // 4\n\t\t\t'11102120': 'F U R UPrime RPrime U R UPrime RPrime FPrime', // 5\n\t\t\t'11210000': 'RPrime UPrime FPrime U F R', // 6\n\t\t\t'11102021': 'FPrime LPrime UPrime L U LPrime UPrime L U F', // 7\n\t\t\t'10011110': 'R L2 BPrime L BPrime LPrime B2 L BPrime L RPrime', // 8\n\t\t\t'00202121': 'LPrime R2 B RPrime B R B2 RPrime B RPrime L', // 9\n\t\t\t'01111111': 'F U R UPrime RPrime FPrime L F U FPrime UPrime LPrime', // 10\n\t\t\t'21212101': 'F U R UPrime RPrime FPrime R B U BPrime UPrime RPrime', // 11\n\t\t\t'21211111': 'F R U RPrime UPrime FPrime B U L UPrime LPrime BPrime', // 12\n\t\t\t'20201010': 'R U2 R2 UPrime R2 UPrime R2 U2 R', // 13\n\t\t\t'01101110': 'R B RPrime L U LPrime UPrime R BPrime RPrime', // 14\n\t\t\t'21002120': 'LPrime BPrime L RPrime UPrime R U LPrime B L', // 15\n\t\t\t'21001100': 'RPrime F R U RPrime UPrime FPrime U R', // 16\n\t\t\t'01000100': 'R U RPrime UPrime MPrime U R UPrime rPrime', // 17\n\t\t\t'01010101': 'M U R U RPrime UPrime M2 U R UPrime rPrime', // 18\n\t\t\t'10211021': 'F R U RPrime UPrime R U RPrime UPrime FPrime B U L UPrime LPrime BPrime', // 19\n\t\t\t'11000120': 'R U RPrime UPrime RPrime F R FPrime', // 20\n\t\t\t'10000020': 'LPrime BPrime R B L BPrime RPrime B', // 21\n\t\t\t'20001000': 'B LPrime BPrime R B L BPrime RPrime', // 22\n\t\t\t'00112001': 'RPrime UPrime RPrime F R FPrime U R', // 23\n\t\t\t'21112111': 'R U2 RPrime RPrime F R FPrime U2 RPrime F R FPrime', // 24\n\t\t\t'10002101': 'R U2 RPrime RPrime F R FPrime R U2 RPrime', // 25\n\t\t\t'21110101': 'M U R U RPrime UPrime MPrime RPrime F R FPrime', // 26\n\t\t\t'11212010': 'F LPrime U2 L U2 L F2 LPrime F', // 27\n\t\t\t'01110020': 'R U RPrime U R UPrime RPrime UPrime RPrime F R FPrime', // 28\n\t\t\t'10012100': 'RPrime UPrime R UPrime RPrime U R U R BPrime RPrime B', // 29\n\t\t\t'10112021': 'RPrime UPrime R UPrime RPrime U FPrime U F R', // 30\n\t\t\t'01110121': 'F U R UPrime RPrime FPrime F U FPrime UPrime FPrime L F LPrime', // 31\n\t\t\t'01112101': 'F U R UPrime RPrime FPrime B U BPrime UPrime SPrime U B UPrime bPrime', // 32\n\t\t\t'21212000': 'lPrime U2 L U LPrime U l', // 33\n\t\t\t'01212020': 'r U RPrime U R U2 rPrime', // 34\n\t\t\t'00202020': 'R U RPrime U R U2 RPrime', // 35\n\t\t\t'10101000': 'RPrime UPrime R URprime RPrime U2 R', // 36\n\t\t\t'01001021': 'RPrime U R U2 RPrime UPrime FPrime U F U R', // 37\n\t\t\t'10200101': 'R UPrime RPrime U2 R U B UPrime BPrime UPrime RPrime', // 38\n\t\t\t'21102011': 'r U RPrime U R UPrime RPrime U R U2 rPrime', // 39\n\t\t\t'21112010': 'lPrime UPrime L UPrime LPrime U L UPrime LPrime U2 l', // 40\n\t\t\t'11100011': 'r U2 RPrime UPrime R UPrime rPrime', // 41\n\t\t\t'11012000': 'F R UPrime RPrime UPrime R U RPrime FPrime', // 42\n\t\t\t'11001011': 'lPrime UPrime L UPrime LPrime U2 l', // 43\n\t\t\t'01010000': 'r U RPrime UPrime M U R UPrime RPrime', // 44\n\t\t\t'01002110': 'R U RPrime UPrime BPrime RPrime F R FPrime B', // 45\n\t\t\t'01202120': 'L FPrime LPrime UPrime L F LPrime FPrime U F', // 46\n\t\t\t'11001110': 'RPrime F R U RPrime FPrime R F UPrime FPrime', // 47\n\t\t\t'10200000': 'R2 D RPrime U2 R DPrime RPrime U2 RPrime', // 48\n\t\t\t'20112011': 'RPrime U2 R2 U RPrime U R U2 BPrime RPrime B', // 49\n\t\t\t'10000121': 'R U BPrime UPrime RPrime U R B RPrime', // 50\n\t\t\t'11000021': 'RPrime UPrime F U R UPrime RPrime FPrime R', // 51\n\t\t\t'01100120': 'L FPrime LPrime UPrime L U F UPrime LPrime', // 52\n\t\t\t'11112020': 'RPrime F R2 FPrime U2 FPrime U2 F RPrime', // 53\n\t\t\t'20110100': 'BPrime RPrime B LPrime BPrime R R BPrime RPrime B2 L', // 54\n\t\t\t'20100101': 'B L BPrime R B L2 B L B2 RPrime', // 55\n\t\t\t'01101011': 'FPrime UPrime F L FPrime LPrime U L F LPrime', // 56\n\t\t\t'21012020': 'F U FPrime RPrime F R UPrime RPrime FPrime R', // 57\n\t\t};\n\t}\n\n\tisSolved() {\n\t\treturn this.getOllString() === SOLVED_STATE;\n\t}\n\n\tsolve() {\n\t\treturn this._solve();\n\t}\n\n\t_getCaseNumber() {\n\t\treturn this.getOllString();\n\t}\n\n\t_solveCase(ollString) {\n\t\tlet pattern = this.findPattern(ollString);\n\t\tlet algorithm = this.getAlgorithm(pattern);\n\t\tlet frontFace = this._getFrontFace(ollString, pattern);\n\n\t\tthis.move(algorithm, {\n\t\t\torientation: { up: 'down', front: frontFace }\n\t\t});\n\t}\n\n\tgetOllString() {\n\t\tlet orientations = [];\n\n\t\tlet cubies = this._getOllCubies();\n\t\tcubies.forEach(cubie => {\n\t\t\tlet orientation = this._getCubieOrientation(cubie);\n\t\t\torientations.push(orientation);\n\t\t});\n\n\t\treturn orientations.join('');\n\t}\n\n\t/**\n\t * @param {string} [ollString] - Probably unnecessary. If passed in, it saves\n\t * a step computing the ollString.\n\t */\n\tfindPattern(ollString) {\n\t\tif (typeof ollString === 'undefined') {\n\t\t\tollString = this.getOllString();\n\t\t}\n\n\t\tfor (let i = 0; i < 4; i++) {\n\t\t\tlet algorithm = this.algorithms[ollString];\n\n\t\t\tif (typeof algorithm === 'string') {\n\t\t\t\treturn ollString;\n\t\t\t} else {\n\t\t\t\tollString = this._rotateOllStringLeft(ollString);\n\t\t\t}\n\t\t}\n\n\t\tthrow new Error(`No pattern found for oll string \"${ollString}\"`);\n\t}\n\n\t/**\n\t * @param {string} [pattern] - The pattern on this OLL or the ollString.\n\t */\n\tgetAlgorithm(pattern) {\n\t\tif (typeof pattern === 'undefined') {\n\t\t\tpattern = this.getPattern(pattern); // pattern can be an ollString\n\t\t}\n\n\t\tif (typeof this.algorithms[pattern] === 'undefined') {\n\t\t\tthrow new Error(`No algorithm found for pattern \"${pattern}\"`);\n\t\t}\n\n\t\treturn this.algorithms[pattern];\n\t}\n\n\t_getOllCubies() {\n\t\tlet positions = [\n\t\t\t['front', 'down', 'right'],\n\t\t\t['front', 'down'],\n\t\t\t['front', 'down', 'left'],\n\t\t\t['left', 'down'],\n\t\t\t['left', 'down', 'back'],\n\t\t\t['back', 'down'],\n\t\t\t['back', 'down', 'right'],\n\t\t\t['right', 'down']\n\t\t];\n\n\t\treturn positions.map(pos => this.cube.getCubie(pos));\n\t}\n\n\t/**\n\t * Returns a number indicating the orientation of the cubie.\n\t * 0 --> The DOWN color is on the DOWN face.\n\t * 1 --> The DOWN color is a clockwise rotation from \"solved\".\n\t * 2 --> The DOWN color is a counter-clockwise rotation from \"solved\".\n\t */\n\t_getCubieOrientation(cubie) {\n\t\tif (cubie.getColorOfFace('down') === 'd') {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// if cubie is an edge piece, return 1\n\t\tif (cubie.isEdge()) {\n\t\t\treturn 1;\n\t\t}\n\n\t\tlet [face1, face2] = cubie.faces().filter(face => face !== 'down');\n\t\tlet dir = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"c\" /* getDirectionFromFaces */])(face1, face2, { up: 'down' });\n\t\tlet rightFace = dir === 'right' ? face2 : face1;\n\n\t\treturn cubie.getColorOfFace(rightFace) === 'd' ? 1 : 2;\n\t}\n\n\t_getFrontFace(ollString, pattern) {\n\t\tlet rotationOrder = ['front', 'left', 'back', 'right'];\n\n\t\tfor (let i = 0; i < 4; i++) {\n\t\t\tif (ollString === pattern) {\n\t\t\t\treturn rotationOrder[i];\n\t\t\t} else {\n\t\t\t\tollString = this._rotateOllStringLeft(ollString);\n\t\t\t}\n\t\t}\n\n\t\tthrow new Error(`OLL string \"${ollString}\" does not resolve to the pattern \"${pattern}\"`);\n\t}\n\n\t_rotateOllStringLeft(ollString) {\n\t\treturn ollString.slice(2) + ollString.slice(0, 2);\n\t}\n\n\t_getPartitionBefore() {\n\t\treturn this.getOllString();\n\t}\n\n\t_getPartitionAfter() {\n\t\treturn null;\n\t}\n}\n\n\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return PLLSolver; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__BaseSolver__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils__ = __webpack_require__(0);\n\n\n\nconst SOLVED_STATE = '0 0 0 0 0 0 0 0';\n\nclass PLLSolver extends __WEBPACK_IMPORTED_MODULE_0__BaseSolver__[\"a\" /* BaseSolver */] {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t\tthis.phase = 'pll';\n\n\t\t// permutations in order based on http://badmephisto.com/pll.php, however\n\t\t// the actual algorithms may be different.\n\t\tthis.algorithms = {\n\t\t\t[SOLVED_STATE]: '', // already solved\n\t\t\t'2 -1 1 -1 1 0 0 2': 'R2 F2 RPrime BPrime R F2 RPrime B RPrime', // #1\n\t\t\t'-1 1 -1 2 2 0 0 1': 'R BPrime R F2 RPrime B R F2 R2', // #2\n\t\t\t'1 -1 2 2 0 0 1 -1': 'R UPrime R U R U R UPrime RPrime UPrime R2', // #3\n\t\t\t'-1 1 -1 1 0 0 2 2': 'R2 U R U RPrime UPrime RPrime UPrime RPrime U RPrime', // #4\n\t\t\t'2 2 2 2 2 2 2 2': 'M M U M M U2 M M U M M', // #5\n\t\t\t'0 1 1 1 1 0 2 2': 'R U RPrime UPrime RPrime F R2 UPrime RPrime UPrime R U RPrime FPrime', // #6\n\t\t\t'1 0 2 0 1 0 0 0': 'R U2 RPrime UPrime R U2 LPrime U RPrime UPrime L', // #7\n\t\t\t'0 2 2 0 1 1 1 1': 'F R UPrime RPrime UPrime R U RPrime FPrime R U RPrime UPrime RPrime F R FPrime', // #8\n\t\t\t'1 -1 -1 2 -1 -1 1 0': 'RPrime U2 R U2 RPrime F R U RPrime UPrime RPrime FPrime R2', // #9\n\t\t\t'0 1 -1 -1 2 -1 -1 1': 'R UPrime RPrime UPrime R U R D RPrime UPrime R DPrime RPrime U2 RPrime', // #10\n\t\t\t'0 2 -1 -1 -1 -1 2 0': 'RPrime U RPrime UPrime BPrime D BPrime DPrime B2 RPrime BPrime R B R', // #11\n\t\t\t'2 -1 -1 -1 -1 2 0 0': 'RPrime UPrime FPrime R U RPrime UPrime RPrime F R2 UPrime RPrime UPrime R U RPrime U R', // #12\n\t\t\t'-1 2 2 2 -1 2 0 2': 'L U LPrime B2 uPrime B UPrime BPrime U BPrime u B2', // #13\n\t\t\t'2 -1 2 0 2 -1 2 2': 'RPrime UPrime R B2 u BPrime U B UPrime B uPrime B2', // #14\n\t\t\t'2 -1 1 1 0 1 1 -1': 'R2 uPrime R UPrime R U RPrime u R2 B UPrime BPrime', // #15\n\t\t\t'1 0 1 1 -1 2 -1 1': 'R2 u RPrime U RPrime UPrime R uPrime R2 FPrime U F', // #16\n\t\t\t'1 -1 -1 1 1 -1 -1 1': 'U RPrime UPrime R UPrime R U R UPrime RPrime U R U R2 UPrime RPrime', // #17\n\t\t\t'0 1 0 0 0 1 0 2': 'LPrime U2 L U LPrime U2 R UPrime L U RPrime', // #18\n\t\t\t'1 1 -1 -1 1 1 -1 -1': 'R BPrime RPrime F R B RPrime FPrime R B RPrime F R BPrime RPrime FPrime', // #19\n\t\t\t'2 0 2 0 2 0 2 0': 'R U RPrime U R U RPrime FPrime R U RPrime UPrime RPrime F R2 UPrime RPrime U2 R UPrime RPrime', // #20\n\t\t\t'0 2 0 2 0 2 0 2': 'RPrime U R UPrime RPrime FPrime UPrime F R U RPrime F RPrime FPrime R UPrime R', // #21\n\t\t};\n\t}\n\n\tsolve() {\n\t\treturn this._solve();\n\t}\n\n\t_getCaseNumber() {\n\t\treturn this.getPllString();\n\t}\n\n\t_solveCase(pllString) {\n\t\tlet pattern = this.findPattern(pllString);\n\t\tlet algorithm = this.getAlgorithm(pattern);\n\t\tlet frontFace = this._getFrontFace(pllString, pattern);\n\n\t\tthis.move(algorithm, {\n\t\t\torientation: { up: 'down', front: frontFace }\n\t\t});\n\n\t\t// may need an extra rotation of DOWN for a complete solve\n\t\tlet cubie = this.cube.getCubie(['down', 'front']); // any cubie on DOWN\n\t\tlet origin = 'front';\n\t\tlet target = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__[\"a\" /* getFaceOfMove */])(cubie.getColorOfFace(origin));\n\t\tlet lastLayerMove = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__[\"b\" /* getRotationFromTo */])('down', origin, target);\n\n\t\tthis.move(lastLayerMove);\n\t}\n\n\tisSolved() {\n\t\treturn this.cube.isSolved();\n\t}\n\n\t/**\n\t * Permutations are unique in the way that each cubie is permutated relative\n\t * to the one adjacent to it. For each cubie (in order), find the relative\n\t * direction from its color to the next cubie's color, and turn it into a\n\t * number. This will allow each permutation to be held in a unique string.\n\t */\n\tgetPllString() {\n\t\tlet pllString = [];\n\t\tlet pllCubies = this._getPllCubies();\n\n\t\tlet faces = ['front', 'left', 'back', 'right']; // we're upside down\n\n\t\tfor (let i = 0; i < pllCubies.length; i++) {\n\t\t\tlet cubie1 = pllCubies[i];\n\t\t\tlet cubie2 = pllCubies[i + 1];\n\t\t\tlet faceToCheck = faces[~~(i / 2)];\n\n\t\t\t// get the colors of the two cubies\n\t\t\tlet color1 = cubie1.getColorOfFace(faceToCheck);\n\n\t\t\t// wrap around to the first cubie\n\t\t\tif (!cubie2) {\n\t\t\t\tcubie2 = pllCubies[0];\n\t\t\t}\n\t\t\tlet color2 = cubie2.getColorOfFace(faceToCheck);\n\n\t\t\t// find the direction between the two\n\t\t\tlet face1 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__[\"a\" /* getFaceOfMove */])(color1);\n\t\t\tlet face2 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__[\"a\" /* getFaceOfMove */])(color2);\n\n\t\t\t// turn it into a number\n\t\t\tlet direction = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__[\"c\" /* getDirectionFromFaces */])(face1, face2, { up: 'down' });\n\t\t\tif (direction === 'front') direction = 0;\n\t\t\tif (direction === 'right') direction = 1;\n\t\t\tif (direction === 'left') direction = -1;\n\t\t\tif (direction === 'back') direction = 2;\n\n\t\t\tpllString.push(direction);\n\t\t}\n\n\t\treturn pllString.join(' ');\n\t}\n\n\tfindPattern(pllString) {\n\t\tlet initialString = pllString;\n\n\t\tif (typeof pllString === 'undefined') {\n\t\t\tpllString = this.getPllString();\n\t\t}\n\n\t\tfor (let i = 0; i < 4; i++) {\n\t\t\tlet algorithm = this.algorithms[pllString];\n\n\t\t\tif (typeof algorithm === 'string') {\n\t\t\t\treturn pllString;\n\t\t\t} else {\n\t\t\t\tpllString = this._rotatePllStringLeft(pllString);\n\t\t\t}\n\t\t}\n\n\t\tthrow new Error(`No pattern found for pll string \"${initialString}\"`);\n\t}\n\n\tgetAlgorithm(pattern) {\n\t\tif (typeof pattern === 'undefined') {\n\t\t\tpattern = this.findPattern(pattern); // pattern can be a pllString\n\t\t}\n\n\t\tif (typeof this.algorithms[pattern] === 'undefined') {\n\t\t\tthrow new Error(`No algorithm found for pattern \"${pattern}\"`);\n\t\t}\n\n\t\treturn this.algorithms[pattern];\n\t}\n\n\t_getPllCubies() {\n\t\tlet positions = [\n\t\t\t['front', 'down', 'right'],\n\t\t\t['front', 'down'],\n\t\t\t['front', 'down', 'left'],\n\t\t\t['left', 'down'],\n\t\t\t['left', 'down', 'back'],\n\t\t\t['back', 'down'],\n\t\t\t['back', 'down', 'right'],\n\t\t\t['right', 'down']\n\t\t];\n\n\t\treturn positions.map(pos => this.cube.getCubie(pos));\n\t}\n\n\t_getCubiePermutation(cubie) {\n\t\t// pick a face, any face (expect for the down face)\n\t\tlet face = cubie.faces().find(face => face !== 'down');\n\n\t\t// get the cube face this face lies on\n\t\tlet cubeFace = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__[\"a\" /* getFaceOfMove */])(cubie.getColorOfFace(face));\n\n\t\t// find the move that will permute the cubie correctly\n\t\tlet moveToSolveCubie = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__[\"b\" /* getRotationFromTo */])('down', face, cubeFace);\n\t\tmoveToSolveCubie = moveToSolveCubie.toLowerCase();\n\n\t\t// translate the move to a number\n\t\tlet dir;\n\t\tif (moveToSolveCubie === '') dir = 0;\n\t\telse if (moveToSolveCubie.includes('prime')) dir = 1;\n\t\telse if (moveToSolveCubie.split(' ').length > 1) dir = 2;\n\t\telse dir = -1;\n\n\t\treturn dir;\n\t}\n\n\t_rotatePllStringLeft(pllString) {\n\t\tlet arr = pllString.split(' ').map(num => parseInt(num));\n\t\treturn [...arr.slice(2), ...arr.slice(0, 2)].join(' ');\n\t}\n\n\t_getFrontFace(pllString, pattern) {\n\t\tlet rotationOrder = ['front', 'left', 'back', 'right'];\n\n\t\tfor (let i = 0; i < 4; i++) {\n\t\t\tif (pllString === pattern) {\n\t\t\t\treturn rotationOrder[i];\n\t\t\t} else {\n\t\t\t\tpllString = this._rotatePllStringLeft(pllString);\n\t\t\t}\n\t\t}\n\n\t\tthrow new Error(`OLL string \"${pllString}\" does not resolve to the pattern \"${pattern}\"`);\n\t}\n}\n\n\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nmodule.exports = function () {\n\treturn /[\\u001b\\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;\n};\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports) {\n\nmodule.exports = cross;\n\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction cross(out, a, b) {\n    var ax = a[0], ay = a[1], az = a[2],\n        bx = b[0], by = b[1], bz = b[2]\n\n    out[0] = ay * bz - az * by\n    out[1] = az * bx - ax * bz\n    out[2] = ax * by - ay * bx\n    return out\n}\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports) {\n\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Face; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Vector__ = __webpack_require__(4);\n\n\nconst faceToNormal = {\n\tfront: '0 0 1',\n\tright: '1 0 0',\n\tup: '0 1 0',\n\tdown: '0 -1 0',\n\tleft: '-1 0 0',\n\tback: '0 0 -1'\n};\n\nclass Face {\n\t/**\n\t * Factory method.\n\t * @param {string|array} normal - The normal that identifies this face.\n\t * @return {Face}\n\t */\n\tstatic FromNormal(normal) {\n\t\tif (typeof normal === 'string') {\n\t\t\tnormal = __WEBPACK_IMPORTED_MODULE_0__Vector__[\"a\" /* Vector */].FromString(normal).toArray();\n\t\t}\n\n\t\treturn new Face(Face.getFace(normal));\n\t}\n\n\t/**\n\t * @param {string} face - A string that identifies a face.\n\t * @return {array}\n\t */\n\tstatic getNormal(face) {\n\t\treturn __WEBPACK_IMPORTED_MODULE_0__Vector__[\"a\" /* Vector */].FromString(faceToNormal[face]).toArray();\n\t}\n\n\t/**\n\t * @param {string|array} normal - The normal that identifies a face.\n\t * @return {string}\n\t */\n\tstatic getFace(normal) {\n\t\tif (typeof normal === 'string') {\n\t\t\tnormal = __WEBPACK_IMPORTED_MODULE_0__Vector__[\"a\" /* Vector */].FromString(normal).toArray();\n\t\t}\n\n\t\tfor (let face of Object.keys(faceToNormal)) {\n\t\t\tif (normal.join(' ') === faceToNormal[face]) {\n\t\t\t\treturn face;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} face - The string of a face, e.g. 'RIGHT'.\n\t */\n\tconstructor(face) {\n\t\tif (typeof face !== 'string') {\n\t\t\tthrow new Error(`\"face\" must be a string (received: ${face})`);\n\t\t}\n\n\t\tface = face.toLowerCase();\n\n\t\tthis.vector = __WEBPACK_IMPORTED_MODULE_0__Vector__[\"a\" /* Vector */].FromString(faceToNormal[face]);\n\t}\n\n\t/**\n\t * Method to return the normal as an array.\n\t * @return {array}\n\t */\n\tnormal() {\n\t\treturn this.vector.toArray();\n\t}\n\n\t/**\n\t * @return {string}\n\t */\n\ttoString() {\n\t\treturn Face.getFace(this.normal());\n\t}\n\n\t/**\n\t * Simulates an orientation change where this face becomes the new given face.\n\t * NOTE: this only changes this face's normals, not any cubies' positions.\n\t * @param {string|Face} face - The new face, e.g. 'FRONT'\n\t */\n\torientTo(newFace) {\n\t\tif (typeof newFace === 'string') {\n\t\t\tnewFace = new Face(newFace);\n\t\t}\n\n\t\tlet { axis, angle } = __WEBPACK_IMPORTED_MODULE_0__Vector__[\"a\" /* Vector */].getRotationFromNormals(this.normal(), newFace.normal());\n\t\tthis.vector.rotate(axis, angle);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Convenience method for rotating this face. NOTE: this only changes this\n\t * face's normals, not any cubies' positions.\n\t * @param {string} axis - Axis of rotation.\n\t * @param {number} angle - Angle of rotation.\n\t * @return {Face}\n\t */\n\trotate(axis, angle) {\n\t\tthis.vector.rotate(axis, angle);\n\t\treturn this;\n\t}\n}\n\nFace.FRONT = new Face('FRONT');\nFace.RIGHT = new Face('RIGHT');\nFace.UP = new Face('UP');\nFace.DOWN = new Face('DOWN');\nFace.LEFT = new Face('LEFT');\nFace.BACK = new Face('BACK');\n\n\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return F2LBaseSolver; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__BaseSolver__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__models_RubiksCube__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils__ = __webpack_require__(0);\n\n\n\n\nconst R = (moves) => __WEBPACK_IMPORTED_MODULE_1__models_RubiksCube__[\"a\" /* RubiksCube */].reverseMoves(moves);\n\nclass F2LBaseSolver extends __WEBPACK_IMPORTED_MODULE_0__BaseSolver__[\"a\" /* BaseSolver */] {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\n\t\tthis.phase = 'f2l';\n\t}\n\n\tcolorsMatch({ corner, edge }) {\n\t\tlet colors = edge.colors();\n\n\t\tif (corner.colors().includes(colors[0]) && corner.colors().includes(colors[1])) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns true only if the pair is matched and in the correct slot.\n\t */\n\tisPairSolved({ corner, edge }) {\n\t\tif (!this.isPairMatched({ corner, edge })) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// is the corner on the cross face?\n\t\tif (corner.getFaceOfColor('u') !== 'up') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// are the edge's colors on the correct face? (e.g. is the edge's 'F' color\n\t\t// on the 'FRONT' face)?\n\t\tfor (let color of edge.colors()) {\n\t\t\tif (edge.getFaceOfColor(color) !== __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* getFaceOfMove */])(color)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tisPairMatched({ corner, edge }) {\n\t\t// are the two non-cross colors the same?\n\t\tif (!this.colorsMatch({ corner, edge })) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// for each color, do the corner and edge share the same face?\n\t\tfor (let color of edge.colors()) {\n\t\t\tif (corner.getFaceOfColor(color) !== edge.getFaceOfColor(color)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tisPairSeparated({ corner, edge }) {\n\t\t// colors must match\n\t\tif (!this.colorsMatch({ corner, edge })) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// corner's white face cannot be UP or DOWN\n\t\tif (['up', 'down'].includes(corner.getFaceOfColor('u'))) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// edge must be on the DOWN face\n\t\tif (!edge.faces().includes('down')) {\n\t\t\treturn false;\n\t\t}\n\n\n\t\tlet otherColor = corner.colors().find(color => {\n\t\t\treturn color !== 'u' && corner.getFaceOfColor(color) !== 'down';\n\t\t});\n\n\t\t// edge must be oriented properly\n\t\tif (edge.getFaceOfColor(otherColor) !== 'down') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// corner and edge must be one move away from matching\n\t\tlet isOneMoveFromMatched = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"c\" /* getDirectionFromFaces */])(\n\t\t\tcorner.getFaceOfColor(otherColor),\n\t\t\tedge.getFaceOfColor(corner.getColorOfFace('down')),\n\t\t\t{ up: 'up' }\n\t\t) === 'back';\n\n\t\treturn isOneMoveFromMatched;\n\t}\n\n\tsolveMatchedPair({ corner, edge }) {\n\t\tif (!this.isPairMatched({ corner, edge })) {\n\t\t\tthrow new Error('Pair is not matched');\n\t\t}\n\n\t\t// get the color that is not on the down face and is not the crossColor\n\t\tlet matchedColor = edge.colors().find(color => {\n\t\t\treturn edge.getFaceOfColor(color) !== 'down';\n\t\t});\n\n\t\tlet isLeft = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"c\" /* getDirectionFromFaces */])(\n\t\t\tedge.getFaceOfColor(matchedColor),\n\t\t\tcorner.getFaceOfColor('u'),\n\t\t\t{ up: 'down' }\n\t\t) === 'left';\n\n\t\tlet matchingFace = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* getFaceOfMove */])(matchedColor);\n\t\tlet currentFace = corner.getFaceOfColor(matchedColor);\n\t\tlet prepFace = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"e\" /* getFaceFromDirection */])(matchingFace, isLeft ? 'left' : 'right', { up: 'down' });\n\n\t\tlet prep = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"b\" /* getRotationFromTo */])('down', currentFace, prepFace);\n\t\tlet open = isLeft ? matchingFace : R(matchingFace);\n\t\tlet insert = isLeft ? 'DPrime' : 'D';\n\n\t\tlet solveMoves = [prep, open, insert, R(open)].join(' ');\n\t\tthis.move(solveMoves, { upperCase: true });\n\t\treturn solveMoves;\n\t}\n\n\tsolveSeparatedPair({ corner, edge }) {\n\t\tif (!this.isPairSeparated({ corner, edge })) {\n\t\t\tthrow new Error('Pair is not separated');\n\t\t}\n\n\t\t// get the color that is not on the down face and is not the crossColor\n\t\tlet matchedColor = edge.colors().find(color => {\n\t\t\treturn edge.getFaceOfColor(color) !== 'down';\n\t\t});\n\n\t\tlet isLeft = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"c\" /* getDirectionFromFaces */])(\n\t\t\tcorner.getFaceOfColor('u'),\n\t\t\tedge.getFaceOfColor(matchedColor),\n\t\t\t{ up: 'down' }\n\t\t).toUpperCase() === 'LEFT';\n\n\t\tlet currentFace = corner.getFaceOfColor('u');\n\t\tlet prepFace = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* getFaceOfMove */])(matchedColor);\n\n\t\tlet prep = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"b\" /* getRotationFromTo */])('down', currentFace, prepFace);\n\t\tlet match = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"f\" /* getMoveOfFace */])(prepFace);\n\t\tmatch = isLeft ? R(match) : match;\n\t\tlet insert = isLeft ? 'DPrime' : 'D';\n\n\t\tlet solveMoves = [prep, match, insert, R(match)].join(' ');\n\t\tthis.move(solveMoves, { upperCase: true });\n\t\treturn solveMoves;\n\t}\n\n\t_getPartitionBefore({ corner, edge }) {\n\t\treturn {\n\t\t\tcorner: corner.clone(),\n\t\t\tedge: edge.clone()\n\t\t};\n\t}\n\n\t_getPartitionAfter({ corner, edge }) {\n\t\treturn { corner, edge };\n\t}\n}\n\n\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Solver; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__models_RubiksCube__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__solvers_cross__ = __webpack_require__(7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__solvers_f2l__ = __webpack_require__(8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__solvers_oll__ = __webpack_require__(9);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__solvers_pll__ = __webpack_require__(10);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__algorithm_shortener__ = __webpack_require__(2);\n\n\n\n\n\n\n\n\nclass Solver {\n\t/**\n\t * @param {string|RubiksCube} cubeState - Can be one of 3 things:\n\t * 1) A string representing a Rubik's Cube state.\n\t * 2) A string containing a list of moves to make from a solved state to\n\t *    identify a cube state.\n\t * 3) An instance of a RubiksCube.\n\t */\n\tconstructor(cubeState, options) {\n\t\tif (cubeState instanceof __WEBPACK_IMPORTED_MODULE_0__models_RubiksCube__[\"a\" /* RubiksCube */]) {\n\t\t\tthis.cube = cubeState;\n\t\t} else if (typeof cubeState === 'string') {\n\t\t\t// if there are spaces present in cubeState, assume it's a set of\n\t\t\t// scramble moves.\n\t\t\t// it's possible that one or no scramble moves are present.\n\t\t\tlet magicNum = 6; // longest possible move string -- e.g. Rprime\n\t\t\tif (cubeState.split(' ').length > 1 || cubeState.length <= magicNum) {\n\t\t\t\tthis.cube = __WEBPACK_IMPORTED_MODULE_0__models_RubiksCube__[\"a\" /* RubiksCube */].Solved();\n\t\t\t\tthis.cube.move(cubeState);\n\t\t\t} else {\n\t\t\t\tthis.cube = new __WEBPACK_IMPORTED_MODULE_0__models_RubiksCube__[\"a\" /* RubiksCube */](cubeState);\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error('\"cubeState\" is not a valid cubeState. Please provide a list of scramble moves or a string representing a cube state');\n\t\t}\n\n\t\tthis.options = options;\n\t\tthis.phases = ['cross', 'f2l', 'oll', 'pll'];\n\t\tthis.progress = {};\n\n\t\tthis.phases.forEach(phase => this.progress[phase] = []);\n\n\t\t// save each partition to this.progress after each solve\n\t\tconst afterEach = (partition, phase) => {\n\t\t\tthis._updateProgress(partition, phase);\n\t\t};\n\n\t\tthis.currentPhase = null; // good for debugging\n\t\tthis.currentSolver = null; // good for debugging\n\n\t\tthis.crossSolver = new __WEBPACK_IMPORTED_MODULE_1__solvers_cross__[\"a\" /* CrossSolver */](this.cube, this.options);\n\t\tthis.f2lSolver = new __WEBPACK_IMPORTED_MODULE_2__solvers_f2l__[\"a\" /* F2LSolver */](this.cube, this.options);\n\t\tthis.ollSolver = new __WEBPACK_IMPORTED_MODULE_3__solvers_oll__[\"a\" /* OLLSolver */](this.cube, this.options);\n\t\tthis.pllSolver = new __WEBPACK_IMPORTED_MODULE_4__solvers_pll__[\"a\" /* PLLSolver */](this.cube, this.options);\n\n\t\tthis.afterEach('all', afterEach);\n\t}\n\n\tafterEach(phases, callback) {\n\t\t// argument parsing\n\t\tif (typeof phases === 'function') {\n\t\t\t// if first argument is a function, default phases to 'all'\n\t\t\tcallback = phases;\n\t\t\tphases = 'all';\n\t\t} else if (typeof phases === 'string') {\n\t\t\tif (phases === 'all') {\n\t\t\t\t// 'all': shortcut for array of all phases\n\t\t\t\tphases = this.phases.slice();\n\t\t\t} else {\n\t\t\t\t// lastly turn phases into an array\n\t\t\t\tphases = [phases];\n\t\t\t}\n\t\t}\n\n\t\t// error handling\n\t\tif (typeof callback !== 'function') {\n\t\t\tthrow new Error('\"afterEach\" callback is not a function.');\n\t\t}\n\n\t\t// error handling\n\t\tfor (let phase of phases) {\n\t\t\tif (!this.phases.includes(phase)) {\n\t\t\t\tthrow new Error(`Phase \"${phase}\" isn't recognized. Please specify \"cross\", \"f2l\", \"oll\", \"pll\", or \"all\".`);\n\t\t\t}\n\t\t}\n\n\t\t// if everything has gone okay, add the callback\n\t\tfor (let phase of phases) {\n\t\t\tlet solver = this[`${phase}Solver`];\n\t\t\tsolver.afterEach(callback);\n\t\t}\n\t}\n\n\tsolve() {\n\t\tthis.currentPhase = 'cross';\n\t\tthis.currentSolver = this.crossSolver;\n\t\tthis.crossSolver.solve();\n\n\t\tthis.currentPhase = 'f2l';\n\t\tthis.currentSolver = this.f2lSolver;\n\t\tthis.f2lSolver.solve();\n\n\t\tthis.currentPhase = 'oll';\n\t\tthis.currentSolver = this.ollSolver;\n\t\tthis.ollSolver.solve();\n\n\t\tthis.currentPhase = 'pll';\n\t\tthis.currentSolver = this.pllSolver;\n\t\tthis.pllSolver.solve();\n\t}\n\n\tgetMoves() {\n\t\tlet moves = [];\n\n\t\tObject.keys(this.progress).forEach(phase => {\n\t\t\tlet partitions = this.progress[phase];\n\t\t\tpartitions.forEach(partition => moves.push(...partition.moves));\n\t\t});\n\n\t\tmoves = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__utils__[\"h\" /* normalizeNotations */])(moves);\n\n\t\treturn moves.join(' ');\n\t}\n\n\tgetPartitions() {\n\t\tlet ret = {};\n\t\tlet phases = Object.keys(this.progress);\n\t\tphases.forEach(phase => {\n\t\t\tlet partitions = this.progress[phase];\n\n\t\t\tif (partitions.length === 1) {\n\t\t\t\tret[phase] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__algorithm_shortener__[\"a\" /* algorithmShortener */])(partitions[0].moves);\n\t\t\t} else {\n\t\t\t\tlet phaseMoves = [];\n\t\t\t\tthis.progress[phase].forEach(partition => {\n\t\t\t\t\tphaseMoves.push(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__algorithm_shortener__[\"a\" /* algorithmShortener */])(partition.moves));\n\t\t\t\t});\n\t\t\t\tret[phase] = phaseMoves;\n\t\t\t}\n\t\t});\n\n\t\treturn ret;\n\t}\n\n\tisCrossEdgeSolved(edge) {\n\t\treturn this.crossSolver.isEdgeSolved(edge);\n\t}\n\n\tisF2LPairSolved({ corner, edge }) {\n\t\treturn this.f2lSolver.isPairSolved({ corner, edge });\n\t}\n\n\tisOLLSolved() {\n\t\treturn this.ollSolver.isSolved();\n\t}\n\n\tisPLLSolved() {\n\t\treturn this.pllSolver.isSolved();\n\t}\n\n\t_updateProgress(partition, phase) {\n\t\tthis.progress[phase].push(partition);\n\t}\n}\n\n\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(module) {\n\nfunction assembleStyles () {\n\tvar styles = {\n\t\tmodifiers: {\n\t\t\treset: [0, 0],\n\t\t\tbold: [1, 22], // 21 isn't widely supported and 22 does the same thing\n\t\t\tdim: [2, 22],\n\t\t\titalic: [3, 23],\n\t\t\tunderline: [4, 24],\n\t\t\tinverse: [7, 27],\n\t\t\thidden: [8, 28],\n\t\t\tstrikethrough: [9, 29]\n\t\t},\n\t\tcolors: {\n\t\t\tblack: [30, 39],\n\t\t\tred: [31, 39],\n\t\t\tgreen: [32, 39],\n\t\t\tyellow: [33, 39],\n\t\t\tblue: [34, 39],\n\t\t\tmagenta: [35, 39],\n\t\t\tcyan: [36, 39],\n\t\t\twhite: [37, 39],\n\t\t\tgray: [90, 39]\n\t\t},\n\t\tbgColors: {\n\t\t\tbgBlack: [40, 49],\n\t\t\tbgRed: [41, 49],\n\t\t\tbgGreen: [42, 49],\n\t\t\tbgYellow: [43, 49],\n\t\t\tbgBlue: [44, 49],\n\t\t\tbgMagenta: [45, 49],\n\t\t\tbgCyan: [46, 49],\n\t\t\tbgWhite: [47, 49]\n\t\t}\n\t};\n\n\t// fix humans\n\tstyles.colors.grey = styles.colors.gray;\n\n\tObject.keys(styles).forEach(function (groupName) {\n\t\tvar group = styles[groupName];\n\n\t\tObject.keys(group).forEach(function (styleName) {\n\t\t\tvar style = group[styleName];\n\n\t\t\tstyles[styleName] = group[styleName] = {\n\t\t\t\topen: '\\u001b[' + style[0] + 'm',\n\t\t\t\tclose: '\\u001b[' + style[1] + 'm'\n\t\t\t};\n\t\t});\n\n\t\tObject.defineProperty(styles, groupName, {\n\t\t\tvalue: group,\n\t\t\tenumerable: false\n\t\t});\n\t});\n\n\treturn styles;\n}\n\nObject.defineProperty(module, 'exports', {\n\tenumerable: true,\n\tget: assembleStyles\n});\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(32)(module)))\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\nlet chalk;\nlet DEBUG;\n\nconst DEFAULTS = {\n\tcancel() {\n\t\treturn false;\n\t},\n\tignore() {\n\t\treturn false;\n\t}\n};\n\nclass Combiner {\n\tconstructor(input, options) {\n\t\tthis.options = Object.assign({}, DEFAULTS, options);\n\n\t\tif (this.options.DEBUG) {\n\t\t\tchalk = __webpack_require__(20);\n\t\t\tDEBUG = options.DEBUG;\n\t\t}\n\n\t\tthis.input = input.slice();\n\t\tthis.output = [];\n\t}\n\n\trun() {\n\t\tif (this.input.length <= 1) {\n\t\t\treturn this.input;\n\t\t}\n\n\t\tthis.temp = [this.input.shift()];\n\n\t\tlet action, actionValue, tempSnapshot; // for debugging\n\n\t\twhile (this.temp.length > 0) {\n\t\t\tdebug(() => {\n\t\t\t\tconsole.log(chalk.bold('========= START ========='));\n\t\t\t\tthis._logInfo();\n\t\t\t\tconsole.log();\n\t\t\t});\n\n\t\t\t// find the first element that shouldn't be ignored\n\t\t\tlet notIgnoredIdx, notIgnoredEl;\n\n\t\t\tif (this.temp.length === 1) {\n\t\t\t\tnotIgnoredIdx = 0;\n\t\t\t\tnotIgnoredEl = this.input[notIgnoredIdx];\n\n\t\t\t\twhile (notIgnoredIdx < this.input.length && this.options.ignore(this.temp[0], notIgnoredEl)) {\n\t\t\t\t\tnotIgnoredEl = this.input[++notIgnoredIdx];\n\t\t\t\t}\n\n\t\t\t\tif (notIgnoredIdx < this.input.length) {\n\t\t\t\t\tthis.temp.push(notIgnoredEl);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdebug(() => tempSnapshot = this.temp.slice());\n\n\t\t\tif (this.temp.length === 0) {\n\t\t\t\tdebug(() => {\n\t\t\t\t\tconsole.log(chalk.green('breaking'));\n\t\t\t\t\tconsole.log(chalk.bold('========= END ========='));\n\t\t\t\t\tconsole.log();\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (this.temp.length === 1) {\n\t\t\t\tthis.output.push(this.temp.pop());\n\t\t\t\tthis.populateTempForward();\n\n\t\t\t\tdebug(() => {\n\t\t\t\t\tconsole.log(chalk.green('continuing'));\n\t\t\t\t\tthis._logInfo();\n\t\t\t\t\tconsole.log(chalk.bold('========= END ========='));\n\t\t\t\t\tconsole.log();\n\t\t\t\t});\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (this.options.compare(this.temp[0], this.temp[1])) {\n\t\t\t\t// remove the combined element from the input array\n\t\t\t\tif (notIgnoredIdx !== undefined) {\n\t\t\t\t\tthis.input.splice(notIgnoredIdx, 1);\n\t\t\t\t}\n\t\t\t\tconst value = this.options.combine(this.temp[0], this.temp[1]);\n\n\t\t\t\tdebug(() => {\n\t\t\t\t\taction = 'Combining:';\n\t\t\t\t\tactionValue = value;\n\t\t\t\t});\n\n\t\t\t\tthis.temp = this.options.cancel(value) ? [] : [value];\n\n\t\t\t\tthis.populateTempBackward();\n\t\t\t\tif (this.temp.length === 0) {\n\t\t\t\t\tthis.populateTempForward();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.output.push(this.temp.shift());\n\n\t\t\t\t// This keeps elements in order.\n\t\t\t\t// if (notIgnoredIdx === 0) {\n\t\t\t\t// \tthis.input.splice(notIgnoredIdx, 1);\n\t\t\t\t// } else {\n\t\t\t\t// \tthis.temp = this.input.splice(0, 1);\n\t\t\t\t// }\n\n\t\t\t\tif (notIgnoredIdx !== undefined) {\n\t\t\t\t\tif (notIgnoredIdx > 0) {\n\t\t\t\t\t\tthis.temp = this.input.splice(0, 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.input.splice(notIgnoredIdx, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdebug(() => action = 'Skipping:');\n\t\t\t}\n\n\t\t\tdebug(() => {\n\t\t\t\t// log the action taken\n\t\t\t\tconsole.log(chalk.green(action), tempSnapshot);\n\t\t\t\tconsole.log(chalk.green('value:'), actionValue);\n\t\t\t\tconsole.log();\n\n\t\t\t\t// log the status\n\t\t\t\tthis._logInfo();\n\t\t\t\tconsole.log(chalk.bold('========= END ========='));\n\t\t\t\tconsole.log();\n\n\t\t\t\taction = null;\n\t\t\t\tactionValue = null;\n\t\t\t\ttempSnapshot = null;\n\t\t\t});\n\t\t}\n\n\t\tdebug(() => {\n\t\t\tconsole.log(chalk.bold.green('========= FINAL ========='));\n\t\t\tthis._logInfo();\n\t\t\tconsole.log(chalk.bold.green('========= FINAL ========='));\n\t\t\tconsole.log();\n\t\t});\n\n\t\treturn this.output;\n\t}\n\n\tpopulateTempBackward() {\n\t\tif (this.output.length > 0) {\n\t\t\tthis.temp.unshift(this.output.pop());\n\t\t}\n\t}\n\n\tpopulateTempForward() {\n\t\tif (this.input.length > 0) {\n\t\t\tthis.temp.push(this.input.shift());\n\t\t}\n\t}\n\n\t_logInfo() {\n\t\tconsole.log(chalk.bold('output'), this.output);\n\t\tconsole.log(chalk.bold('temp'), this.temp);\n\t\tconsole.log(chalk.bold('input'), this.input);\n\t}\n}\n\nmodule.exports = Combiner;\n\n\n//=======================================================\n// Debugging functions\n//=======================================================\nfunction debug(callback) {\n\tif (!DEBUG) {\n\t\treturn;\n\t}\n\n\tcallback && callback();\n}\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\nconst Combiner = __webpack_require__(18);\n\n/**\n * Given an array, combines adjacent elements. Callbacks that indicate if two\n * elements can be combined and what the combined value is must be given. When\n * two elements are combined, both elements are removed from the output array\n * and in their place is the combined value. If the combined value is undefined\n * then both elements are removed and nothing is inserted in their place. When\n * the combined value is inserted, the following elements will be compared with\n * the combined value and not the original element.\n *\n * @param {array} array - The input array.\n * @param {object} options - Options.\n * @param {function} [options.cancel] - Returns a boolean indicating whether two elements should be cancelled (and no value is inserted).\n * @param {function} options.combine - Returns the combined value of two elements.\n * @param {function} options.compare - Returns a boolean indicating whether two elements can be combined.\n * @param {function} [options.ignore] - Returns a boolean indicating whether to ignore an element and continue with the next.\n */\nmodule.exports = (input, options = {}) => {\n\tvalidateInput(input, options);\n\n\tconst combiner = new Combiner(input, options);\n\treturn combiner.run();\n};\n\n\n//=======================================================\n// Helper functions\n//=======================================================\nfunction validateInput(input, options) {\n\tif (!input) {\n\t\tthrow new Error(`Why are you even importing this.`);\n\t}\n\n\tif (!options.compare) {\n\t\tthrow new Error(`options.compare callback must be present`);\n\t}\n\n\tif (!options.combine) {\n\t\tthrow new Error(`options.combine callback must be present`);\n\t}\n}\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(process) {\nvar escapeStringRegexp = __webpack_require__(21);\nvar ansiStyles = __webpack_require__(17);\nvar stripAnsi = __webpack_require__(30);\nvar hasAnsi = __webpack_require__(29);\nvar supportsColor = __webpack_require__(31);\nvar defineProps = Object.defineProperties;\nvar isSimpleWindowsTerm = process.platform === 'win32' && !/^xterm/i.test(process.env.TERM);\n\nfunction Chalk(options) {\n\t// detect mode if not set manually\n\tthis.enabled = !options || options.enabled === undefined ? supportsColor : options.enabled;\n}\n\n// use bright blue on Windows as the normal blue color is illegible\nif (isSimpleWindowsTerm) {\n\tansiStyles.blue.open = '\\u001b[94m';\n}\n\nvar styles = (function () {\n\tvar ret = {};\n\n\tObject.keys(ansiStyles).forEach(function (key) {\n\t\tansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');\n\n\t\tret[key] = {\n\t\t\tget: function () {\n\t\t\t\treturn build.call(this, this._styles.concat(key));\n\t\t\t}\n\t\t};\n\t});\n\n\treturn ret;\n})();\n\nvar proto = defineProps(function chalk() {}, styles);\n\nfunction build(_styles) {\n\tvar builder = function () {\n\t\treturn applyStyle.apply(builder, arguments);\n\t};\n\n\tbuilder._styles = _styles;\n\tbuilder.enabled = this.enabled;\n\t// __proto__ is used because we must return a function, but there is\n\t// no way to create a function with a different prototype.\n\t/* eslint-disable no-proto */\n\tbuilder.__proto__ = proto;\n\n\treturn builder;\n}\n\nfunction applyStyle() {\n\t// support varags, but simply cast to string in case there's only one arg\n\tvar args = arguments;\n\tvar argsLen = args.length;\n\tvar str = argsLen !== 0 && String(arguments[0]);\n\n\tif (argsLen > 1) {\n\t\t// don't slice `arguments`, it prevents v8 optimizations\n\t\tfor (var a = 1; a < argsLen; a++) {\n\t\t\tstr += ' ' + args[a];\n\t\t}\n\t}\n\n\tif (!this.enabled || !str) {\n\t\treturn str;\n\t}\n\n\tvar nestedStyles = this._styles;\n\tvar i = nestedStyles.length;\n\n\t// Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,\n\t// see https://github.com/chalk/chalk/issues/58\n\t// If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.\n\tvar originalDim = ansiStyles.dim.open;\n\tif (isSimpleWindowsTerm && (nestedStyles.indexOf('gray') !== -1 || nestedStyles.indexOf('grey') !== -1)) {\n\t\tansiStyles.dim.open = '';\n\t}\n\n\twhile (i--) {\n\t\tvar code = ansiStyles[nestedStyles[i]];\n\n\t\t// Replace any instances already present with a re-opening code\n\t\t// otherwise only the part of the string until said closing code\n\t\t// will be colored, and the rest will simply be 'plain'.\n\t\tstr = code.open + str.replace(code.closeRe, code.open) + code.close;\n\t}\n\n\t// Reset the original 'dim' if we changed it to work around the Windows dimmed gray issue.\n\tansiStyles.dim.open = originalDim;\n\n\treturn str;\n}\n\nfunction init() {\n\tvar ret = {};\n\n\tObject.keys(styles).forEach(function (name) {\n\t\tret[name] = {\n\t\t\tget: function () {\n\t\t\t\treturn build.call(this, [name]);\n\t\t\t}\n\t\t};\n\t});\n\n\treturn ret;\n}\n\ndefineProps(Chalk.prototype, init());\n\nmodule.exports = new Chalk();\nmodule.exports.styles = ansiStyles;\nmodule.exports.hasColor = hasAnsi;\nmodule.exports.stripColor = stripAnsi;\nmodule.exports.supportsColor = supportsColor;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13)))\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar matchOperatorsRe = /[|\\\\{}()[\\]^$+*?.]/g;\n\nmodule.exports = function (str) {\n\tif (typeof str !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\treturn str.replace(matchOperatorsRe, '\\\\$&');\n};\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = angle\n\nvar fromValues = __webpack_require__(24)\nvar normalize = __webpack_require__(25)\nvar dot = __webpack_require__(23)\n\n/**\n * Get the angle between two 3D vectors\n * @param {vec3} a The first operand\n * @param {vec3} b The second operand\n * @returns {Number} The angle in radians\n */\nfunction angle(a, b) {\n    var tempA = fromValues(a[0], a[1], a[2])\n    var tempB = fromValues(b[0], b[1], b[2])\n \n    normalize(tempA, tempA)\n    normalize(tempB, tempB)\n \n    var cosine = dot(tempA, tempB)\n\n    if(cosine > 1.0){\n        return 0\n    } else {\n        return Math.acos(cosine)\n    }     \n}\n\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports) {\n\nmodule.exports = dot;\n\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} dot product of a and b\n */\nfunction dot(a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n}\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports) {\n\nmodule.exports = fromValues;\n\n/**\n * Creates a new vec3 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} a new 3D vector\n */\nfunction fromValues(x, y, z) {\n    var out = new Float32Array(3)\n    out[0] = x\n    out[1] = y\n    out[2] = z\n    return out\n}\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports) {\n\nmodule.exports = normalize;\n\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to normalize\n * @returns {vec3} out\n */\nfunction normalize(out, a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2]\n    var len = x*x + y*y + z*z\n    if (len > 0) {\n        //TODO: evaluate use of glm_invsqrt here?\n        len = 1 / Math.sqrt(len)\n        out[0] = a[0] * len\n        out[1] = a[1] * len\n        out[2] = a[2] * len\n    }\n    return out\n}\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports) {\n\nmodule.exports = rotateX;\n\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\nfunction rotateX(out, a, b, c){\n    var by = b[1]\n    var bz = b[2]\n\n    // Translate point to the origin\n    var py = a[1] - by\n    var pz = a[2] - bz\n\n    var sc = Math.sin(c)\n    var cc = Math.cos(c)\n\n    // perform rotation and translate to correct position\n    out[0] = a[0]\n    out[1] = by + py * cc - pz * sc\n    out[2] = bz + py * sc + pz * cc\n\n    return out\n}\n\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports) {\n\nmodule.exports = rotateY;\n\n/**\n * Rotate a 3D vector around the y-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\nfunction rotateY(out, a, b, c){\n    var bx = b[0]\n    var bz = b[2]\n\n    // translate point to the origin\n    var px = a[0] - bx\n    var pz = a[2] - bz\n    \n    var sc = Math.sin(c)\n    var cc = Math.cos(c)\n  \n    // perform rotation and translate to correct position\n    out[0] = bx + pz * sc + px * cc\n    out[1] = a[1]\n    out[2] = bz + pz * cc - px * sc\n  \n    return out\n}\n\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports) {\n\nmodule.exports = rotateZ;\n\n/**\n * Rotate a 3D vector around the z-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\nfunction rotateZ(out, a, b, c){\n    var bx = b[0]\n    var by = b[1]\n\n    //Translate point to the origin\n    var px = a[0] - bx\n    var py = a[1] - by\n  \n    var sc = Math.sin(c)\n    var cc = Math.cos(c)\n\n    // perform rotation and translate to correct position\n    out[0] = bx + px * cc - py * sc\n    out[1] = by + px * sc + py * cc\n    out[2] = a[2]\n  \n    return out\n}\n\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar ansiRegex = __webpack_require__(11);\nvar re = new RegExp(ansiRegex().source); // remove the `g` flag\nmodule.exports = re.test.bind(re);\n\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar ansiRegex = __webpack_require__(11)();\n\nmodule.exports = function (str) {\n\treturn typeof str === 'string' ? str.replace(ansiRegex, '') : str;\n};\n\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(process) {\nvar argv = process.argv;\n\nvar terminator = argv.indexOf('--');\nvar hasFlag = function (flag) {\n\tflag = '--' + flag;\n\tvar pos = argv.indexOf(flag);\n\treturn pos !== -1 && (terminator !== -1 ? pos < terminator : true);\n};\n\nmodule.exports = (function () {\n\tif ('FORCE_COLOR' in process.env) {\n\t\treturn true;\n\t}\n\n\tif (hasFlag('no-color') ||\n\t\thasFlag('no-colors') ||\n\t\thasFlag('color=false')) {\n\t\treturn false;\n\t}\n\n\tif (hasFlag('color') ||\n\t\thasFlag('colors') ||\n\t\thasFlag('color=true') ||\n\t\thasFlag('color=always')) {\n\t\treturn true;\n\t}\n\n\tif (process.stdout && !process.stdout.isTTY) {\n\t\treturn false;\n\t}\n\n\tif (process.platform === 'win32') {\n\t\treturn true;\n\t}\n\n\tif ('COLORTERM' in process.env) {\n\t\treturn true;\n\t}\n\n\tif (process.env.TERM === 'dumb') {\n\t\treturn false;\n\t}\n\n\tif (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {\n\t\treturn true;\n\t}\n\n\treturn false;\n})();\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13)))\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports) {\n\nmodule.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n\n\n/***/ }),\n/* 33 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Solver__ = __webpack_require__(16);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__algorithm_shortener__ = __webpack_require__(2);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"Solver\", function() { return __WEBPACK_IMPORTED_MODULE_0__Solver__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__models_Cubie__ = __webpack_require__(6);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"Cubie\", function() { return __WEBPACK_IMPORTED_MODULE_2__models_Cubie__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__models_RubiksCube__ = __webpack_require__(1);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"RubiksCube\", function() { return __WEBPACK_IMPORTED_MODULE_3__models_RubiksCube__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__solvers_cross__ = __webpack_require__(7);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"CrossSolver\", function() { return __WEBPACK_IMPORTED_MODULE_4__solvers_cross__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__solvers_f2l__ = __webpack_require__(8);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"F2LSolver\", function() { return __WEBPACK_IMPORTED_MODULE_5__solvers_f2l__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__solvers_oll__ = __webpack_require__(9);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"OLLSolver\", function() { return __WEBPACK_IMPORTED_MODULE_6__solvers_oll__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__solvers_pll__ = __webpack_require__(10);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"PLLSolver\", function() { return __WEBPACK_IMPORTED_MODULE_7__solvers_pll__[\"a\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"algorithmShortener\", function() { return __WEBPACK_IMPORTED_MODULE_1__algorithm_shortener__[\"a\"]; });\n\n\n\n// solver constructor\n\n\n// models\n\n\n\n// solvers\n\n\n\n\n\n// algorithm shortener\n\n\n/**\n * @param {string} cubeState - The string representing a cube state.\n * @param {object} options\n * @prop {boolean} options.partitioned - Whether to separate moves according to\n * phase.\n */\n/* harmony default export */ __webpack_exports__[\"default\"] = ((cubeState, options = {}) => {\n\tlet solver = new __WEBPACK_IMPORTED_MODULE_0__Solver__[\"a\" /* Solver */](cubeState, options);\n\tsolver.solve();\n\n\tif (options.partitioned) {\n\t\treturn solver.getPartitions();\n\t} else {\n\t\treturn __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__algorithm_shortener__[\"a\" /* algorithmShortener */])(solver.getMoves());\n\t}\n});\n\n\n/***/ }),\n/* 34 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Case1Solver; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__models_RubiksCube__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__F2LCaseBaseSolver__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils__ = __webpack_require__(0);\n\n\n\n\nconst R = (moves) => __WEBPACK_IMPORTED_MODULE_0__models_RubiksCube__[\"a\" /* RubiksCube */].reverseMoves(moves);\n\n/**\n * Top level case 1:\n * Both corner and edge are on the DOWN face.\n */\nclass Case1Solver extends __WEBPACK_IMPORTED_MODULE_1__F2LCaseBaseSolver__[\"a\" /* F2LCaseBaseSolver */] {\n\t/**\n\t * 10 Cases:\n\t * 1) Pair is matched.\n\t * 2) Pair is separated.\n\t *\n\t * ---- Group 1: Corner's white color is on DOWN face ----\n\t * 3) Corner and edge share a face and colors on that face are equal.\n\t * 4) Corner and edge share a face and colors on that face are not equal.\n\t * 5) Corner and edge do not share a face.\n\t *\n\t * ---- Group 2: Corner's \"other\" color matches edge's \"primary\" color ----\n\t * 6) Corner shares a face with edge.\n\t * 7) Corner does not share a face with edge.\n\t *\n\t * ---- Group 3: Corner's \"other\" color doesn't match edge's \"primary\" color ----\n\t * 8) Edge shares a face with corner's cross color's face.\n\t * 9) Edge shares a face with corner's other color's face.\n\t * 10) Corner does not share a face with edge.\n\t *\n\t * TODO: refactor\n\t */\n\t_getCaseNumber({ corner, edge }) {\n\t\tif (this.isPairMatched({ corner, edge })) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (this.isPairSeparated({ corner, edge })) {\n\t\t\treturn 2;\n\t\t}\n\n\t\tlet sharedFace;\n\t\tedge.faces().forEach(face => {\n\t\t\tif (corner.faces().includes(face) && face !== 'down') {\n\t\t\t\tsharedFace = face;\n\t\t\t}\n\t\t});\n\t\tlet otherColor = corner.colors().find(color => {\n\t\t\treturn color !== 'u' && color !== corner.getColorOfFace('down');\n\t\t});\n\t\tlet primaryColor = edge.colors().find(c => edge.getFaceOfColor(c) !== 'down');\n\n\t\t// Group 1\n\t\tif (corner.getFaceOfColor('u') === 'down') {\n\t\t\tif (sharedFace) {\n\t\t\t\tif (corner.getColorOfFace(sharedFace) === edge.getColorOfFace(sharedFace)) {\n\t\t\t\t\treturn 3;\n\t\t\t\t} else {\n\t\t\t\t\treturn 4;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn 5;\n\t\t\t}\n\t\t}\n\n\t\t// Group 2\n\t\tif (otherColor === primaryColor) {\n\t\t\tif (sharedFace) {\n\t\t\t\treturn 6;\n\t\t\t} else {\n\t\t\t\treturn 7;\n\t\t\t}\n\t\t}\n\n\t\t// Group 3\n\t\tif (sharedFace) {\n\t\t\tif (sharedFace === corner.getFaceOfColor('u')) {\n\t\t\t\treturn 8;\n\t\t\t} else {\n\t\t\t\treturn 9;\n\t\t\t}\n\t\t} else {\n\t\t\treturn 10;\n\t\t}\n\t}\n\n\t_solveCase1({ corner, edge }) {\n\t\treturn this.solveMatchedPair({ corner, edge });\n\t}\n\n\t_solveCase2({ corner, edge }) {\n\t\treturn this.solveSeparatedPair({ corner, edge });\n\t}\n\n\t_solveCase3({ corner, edge }) {\n\t\t// calculate which side the corner is on, the position, etc.\n\t\tlet currentFace = edge.faces().find(face => face !== 'down');\n\t\tlet targetFace = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* getFaceOfMove */])(edge.getColorOfFace('down'));\n\t\tlet prepFace = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"e\" /* getFaceFromDirection */])(targetFace, 'back', { up: 'down' });\n\t\tlet otherFace = corner.getFaceOfColor(edge.getColorOfFace('down'));\n\t\tlet isLeft = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"e\" /* getFaceFromDirection */])(currentFace, otherFace, { up: 'down' }) === 'left';\n\n\t\t// the moves\n\t\tlet prep = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"b\" /* getRotationFromTo */])('down', currentFace, prepFace);\n\t\tlet moveFace = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* getFaceOfMove */])(edge.getColorOfFace(currentFace));\n\t\tlet dir = isLeft ? 'D' : 'DPrime';\n\n\t\tmoveFace = isLeft ? moveFace : R(moveFace);\n\n\t\tlet solveMoves = `${prep} ${moveFace} ${moveFace} D D `;\n\t\tsolveMoves += `${moveFace} ${dir} ${R(moveFace)} ${dir} ${moveFace} ${moveFace}`;\n\t\tthis.move(solveMoves, { upperCase: true });\n\t}\n\n\t_solveCase4({ corner, edge }) {\n\t\t// calculate which side the corner is on, the position, etc.\n\t\tlet currentFace = edge.faces().find(face => face !== 'down');\n\t\tlet targetFace = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* getFaceOfMove */])(edge.getColorOfFace(currentFace));\n\t\tlet otherFace = corner.faces().find(face => !edge.faces().includes(face));\n\t\tlet isLeft = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"e\" /* getFaceFromDirection */])(otherFace, currentFace, { up: 'down' }) === 'left';\n\n\t\t// the moves\n\t\tlet prep = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"b\" /* getRotationFromTo */])('down', currentFace, targetFace);\n\t\tlet moveFace = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"f\" /* getMoveOfFace */])(targetFace);\n\t\tmoveFace = isLeft ? R(moveFace) : moveFace;\n\n\t\tthis.move(`${prep} ${moveFace} D D ${R(moveFace)}`, { upperCase: true });\n\t\tthis.solveSeparatedPair({ corner, edge });\n\t}\n\n\t_solveCase5({ corner, edge }) {\n\t\tlet primary = edge.colors().find(color => edge.getFaceOfColor(color) !== 'down');\n\t\tlet secondary = edge.colors().find(color => edge.getFaceOfColor(color) === 'down');\n\n\t\tlet isLeft = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"e\" /* getFaceFromDirection */])(\n\t\t\t__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* getFaceOfMove */])(primary),\n\t\t\t__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* getFaceOfMove */])(secondary),\n\t\t\t{ up: 'down' }\n\t\t) === 'right';\n\n\t\tlet edgeCurrent = edge.getFaceOfColor(primary);\n\t\tlet edgeTarget = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* getFaceOfMove */])(primary);\n\n\t\t// do the prep move now. need to calculate things after this move is done\n\t\tlet edgePrep = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"b\" /* getRotationFromTo */])('down', edgeCurrent, edgeTarget);\n\t\tthis.move(edgePrep, { upperCase: true });\n\n\t\t// calculate corner stuff\n\t\tlet cornerCurrent = corner.getFaceOfColor(primary);\n\t\tlet cornerTarget = edgeTarget;\n\n\t\t// the moves\n\t\tlet cornerPrep = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"b\" /* getRotationFromTo */])('down', cornerCurrent, cornerTarget);\n\t\tlet open = isLeft ? R(edgeTarget) : edgeTarget;\n\n\t\tthis.move(`${open} ${cornerPrep} ${R(open)}`, { upperCase: true });\n\t\tthis.solveMatchedPair({ corner, edge });\n\t}\n\n\t_solveCase6({ corner, edge }) {\n\t\tlet primary = edge.colors().find(color => edge.getFaceOfColor(color) !== 'down');\n\n\t\tlet currentFace = edge.getFaceOfColor(primary);\n\t\tlet targetFace = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* getFaceOfMove */])(edge.getColorOfFace('down'));\n\t\tlet isLeft = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"c\" /* getDirectionFromFaces */])(\n\t\t\tcurrentFace,\n\t\t\tcorner.getFaceOfColor(primary),\n\t\t\t{ up: 'down' }\n\t\t) === 'left';\n\n\t\tlet prep = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"b\" /* getRotationFromTo */])('down', currentFace, targetFace);\n\t\tlet moveFace = isLeft ? targetFace : R(targetFace);\n\t\tlet dir = isLeft ? 'DPrime' : 'D';\n\n\t\tthis.move(`${prep} ${moveFace} ${dir} ${R(moveFace)}`, { upperCase: true });\n\t\tthis.solveSeparatedPair({ corner, edge});\n\t}\n\n\t_solveCase7({ corner, edge }) {\n\t\tlet primary = edge.colors().find(c => edge.getFaceOfColor(c) !== 'down');\n\t\tlet cornerCurrent = corner.getFaceOfColor('u');\n\t\tlet cornerTarget = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* getFaceOfMove */])(primary);\n\t\tlet isLeft = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"c\" /* getDirectionFromFaces */])(\n\t\t\tcorner.getFaceOfColor(primary),\n\t\t\tcorner.getFaceOfColor('u'),\n\t\t\t{ up: 'down' }\n\t\t) === 'left';\n\n\t\tlet cornerPrep = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"b\" /* getRotationFromTo */])('down', cornerCurrent, cornerTarget);\n\t\tthis.move(cornerPrep, { upperCase: true });\n\n\t\tlet edgeCurrent = edge.getFaceOfColor(primary);\n\t\tlet edgeTarget = corner.getFaceOfColor(primary);\n\n\t\tlet open = isLeft ? corner.getFaceOfColor('u') : R(corner.getFaceOfColor('u'));\n\t\tlet edgeMatch = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"b\" /* getRotationFromTo */])('down', edgeCurrent, edgeTarget);\n\t\tthis.move(`${open} ${edgeMatch} ${R(open)}`, { upperCase: true });\n\n\t\tthis.solveMatchedPair({ corner, edge });\n\t}\n\n\t_solveCase8({ corner, edge }) {\n\t\tlet primary = edge.colors().find(c => edge.getFaceOfColor(c) !== 'down');\n\t\tlet secondary = edge.colors().find(c => edge.getFaceOfColor(c) === 'down');\n\n\t\tlet currentFace = corner.getFaceOfColor(secondary);\n\t\tlet targetFace = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* getFaceOfMove */])(primary);\n\n\t\tlet isLeft = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"c\" /* getDirectionFromFaces */])(\n\t\t\tcurrentFace,\n\t\t\tcorner.getFaceOfColor('u'),\n\t\t\t{ up: 'down' }\n\t\t) === 'left';\n\n\t\tlet prep = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"b\" /* getRotationFromTo */])('down', currentFace, targetFace);\n\t\tlet open = isLeft ? R(targetFace) : targetFace;\n\t\tlet dir = isLeft ? 'D' : 'DPrime';\n\n\t\tthis.move(`${prep} ${open} ${dir} ${R(open)}`, { upperCase: true });\n\t\tthis.solveSeparatedPair({ corner, edge });\n\t}\n\n\t_solveCase9({ corner, edge }) {\n\t\tlet otherColor = edge.colors().find(c => edge.getFaceOfColor(c) === 'down');\n\t\tlet currentFace = corner.getFaceOfColor('u');\n\t\tlet targetFace = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* getFaceOfMove */])(otherColor);\n\n\t\tlet isLeft = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"c\" /* getDirectionFromFaces */])(\n\t\t\tcorner.getFaceOfColor(otherColor),\n\t\t\tcurrentFace,\n\t\t\t{ up: 'down' }\n\t\t) === 'left';\n\n\t\tlet prep = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"b\" /* getRotationFromTo */])('down', currentFace, targetFace);\n\t\tlet moveFace = isLeft ? targetFace : R(targetFace);\n\n\t\tthis.move(`${prep} ${moveFace} D D ${R(moveFace)}`, { upperCase: true });\n\t\tthis.solveSeparatedPair({ corner, edge });\n\t}\n\n\t_solveCase10({ corner, edge }) {\n\t\tlet primary = edge.colors().find(c => edge.getFaceOfColor(c) !== 'down');\n\t\tlet secondary = edge.colors().find(c => edge.getFaceOfColor(c) === 'down');\n\t\tlet cornerCurrent = corner.getFaceOfColor('u');\n\t\tlet cornerTarget = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* getFaceOfMove */])(secondary);\n\t\tlet isLeft = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"c\" /* getDirectionFromFaces */])(\n\t\t\tcorner.getFaceOfColor(secondary),\n\t\t\tcorner.getFaceOfColor('u'),\n\t\t\t{ up: 'down' }\n\t\t) === 'left';\n\n\t\tlet cornerPrep = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"b\" /* getRotationFromTo */])('down', cornerCurrent, cornerTarget);\n\t\tthis.move(cornerPrep, { upperCase: true });\n\n\t\tlet edgeCurrent = edge.getFaceOfColor(primary);\n\t\tlet edgeTarget = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* getFaceOfMove */])(primary);\n\n\t\tlet open = isLeft ? cornerTarget : R(cornerTarget);\n\t\tlet edgePrep = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"b\" /* getRotationFromTo */])('down', edgeCurrent, edgeTarget);\n\n\t\tthis.move(`${open} ${edgePrep} ${R(open)}`, { upperCase: true });\n\t\tthis.solveSeparatedPair({ corner, edge });\n\t}\n}\n\n\n\n\n/***/ }),\n/* 35 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Case2Solver; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__models_RubiksCube__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__F2LCaseBaseSolver__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils__ = __webpack_require__(0);\n\n\n\n\nconst R = (moves) => __WEBPACK_IMPORTED_MODULE_0__models_RubiksCube__[\"a\" /* RubiksCube */].reverseMoves(moves);\n\n/**\n * Top level case 2:\n * Corner is on the DOWN face and edge is not on DOWN or UP face.\n */\nclass Case2Solver extends __WEBPACK_IMPORTED_MODULE_1__F2LCaseBaseSolver__[\"a\" /* F2LCaseBaseSolver */] {\n\t/**\n\t * 4 cases:\n\t *\n\t * ---- Group 1: Corner's white color is on DOWN face ----\n\t * 1) Pair can be matched up.\n\t * 2) Pair cannot be matched up.\n\t *\n\t * ---- Group 2: Corner's white color is not on DOWN face ----\n\t * 3) Corner's other color can match up with the edge color on that face.\n\t * 4) Corner's other color cannot match up with the edge color on that face.\n\t */\n\t_getCaseNumber({ corner, edge }) {\n\t\t// get relative right faces of corner and edge\n\t\tlet cFaces = corner.faces().filter(face => face !== 'down');\n\t\tlet eFaces = edge.faces();\n\t\tlet cornerDir = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"c\" /* getDirectionFromFaces */])(cFaces[0], cFaces[1], { up: 'down' });\n\t\tlet edgeDir = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"c\" /* getDirectionFromFaces */])(eFaces[0], eFaces[1], { up: 'down' });\n\t\tlet cornerRight = cornerDir === 'right' ? cFaces[1] : cFaces[0];\n\t\tlet edgeRight = edgeDir === 'right' ? eFaces[1] : eFaces[0];\n\n\t\tif (corner.getFaceOfColor('u') === 'down') {\n\t\t\tif (corner.getColorOfFace(cornerRight) === edge.getColorOfFace(edgeRight)) {\n\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t}\n\n\t\tlet otherColor = corner.colors().find(color => {\n\t\t\treturn color !== 'u' && color !== corner.getColorOfFace('down');\n\t\t});\n\t\tlet isLeft = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"c\" /* getDirectionFromFaces */])(\n\t\t\tcorner.getFaceOfColor(otherColor),\n\t\t\tcorner.getFaceOfColor('u'),\n\t\t\t{ up: 'down' }\n\t\t) === 'left';\n\t\tlet matchingEdgeColor = isLeft ?\n\t\t\tedge.getColorOfFace(edgeRight) :\n\t\t\tedge.colors().find(c => edge.getFaceOfColor(c) !== edgeRight);\n\n\t\tif (otherColor === matchingEdgeColor) {\n\t\t\treturn 3;\n\t\t} else {\n\t\t\treturn 4;\n\t\t}\n\t}\n\n\t_solveCase1({ corner, edge }) {\n\t\tlet color = edge.colors()[0];\n\t\tlet currentFace = corner.getFaceOfColor(color);\n\t\tlet targetFace = edge.getFaceOfColor(color);\n\n\t\tlet prep = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"b\" /* getRotationFromTo */])('down', currentFace, targetFace);\n\t\tthis.move(prep, { upperCase: true });\n\n\t\tlet [face1, face2] = edge.faces();\n\t\tlet dir = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"c\" /* getDirectionFromFaces */])(face1 , face2, { up: 'down' });\n\t\tlet rightFace = dir === 'right' ? face2 : face1;\n\n\t\tthis.move(`${rightFace} DPrime ${R(rightFace)}`, { upperCase: true });\n\t\tthis.solveMatchedPair({ corner, edge });\n\t}\n\n\t_solveCase2({ corner, edge }) {\n\t\tlet currentFace = corner.getFaceOfColor(edge.colors()[0]);\n\t\tlet targetFace = edge.getFaceOfColor(edge.colors()[1]);\n\n\t\tlet prep = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"b\" /* getRotationFromTo */])('down', currentFace, targetFace);\n\t\tthis.move(prep, { upperCase: true });\n\n\t\tlet dir = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"c\" /* getDirectionFromFaces */])(edge.faces()[0], edge.faces()[1], { up: 'down' });\n\t\tlet rightFace = edge.faces()[dir === 'right' ? 1 : 0];\n\n\t\tthis.move(`${rightFace} D ${R(rightFace)} DPrime`, { upperCase: true });\n\t\tthis.move(`${rightFace} D ${R(rightFace)}`, { upperCase: true });\n\n\t\tthis.solveSeparatedPair({ corner, edge });\n\t}\n\n\t_solveCase3({ corner, edge }) {\n\t\tthis._case3And4Helper({ corner, edge }, 3);\n\t}\n\n\t_solveCase4({ corner, edge }) {\n\t\tthis._case3And4Helper({ corner, edge }, 4);\n\t}\n\n\t_case3And4Helper({ corner, edge }, caseNum) {\n\t\tlet downColor = corner.getColorOfFace('down');\n\t\tlet otherColor = corner.colors().find(c => ![downColor, 'u'].includes(c));\n\t\tlet matchingColor = caseNum === 3 ? otherColor : downColor;\n\t\tlet isLeft = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"c\" /* getDirectionFromFaces */])(\n\t\t\tcorner.getFaceOfColor(otherColor),\n\t\t\tcorner.getFaceOfColor('u'),\n\t\t\t{ up: 'down' }\n\t\t) === 'left';\n\n\t\tlet currentFace = corner.getFaceOfColor('u');\n\t\t// let targetFace = getFaceOfMove(otherColor)\n\t\tlet targetFace = edge.getFaceOfColor(matchingColor);\n\n\t\tlet prep = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"b\" /* getRotationFromTo */])('down', currentFace, targetFace);\n\t\tlet moveFace = isLeft ? targetFace : R(targetFace);\n\t\tlet dir = isLeft ? 'DPrime' : 'D';\n\t\tdir = caseNum === 4 ? R(dir) : dir;\n\n\t\tthis.move(`${prep} ${moveFace} ${dir} ${R(moveFace)}`, { upperCase: true });\n\n\t\tlet method = `solve${caseNum === 3 ? 'Matched' : 'Separated'}Pair`;\n\t\tthis[method]({ corner, edge });\n\t}\n}\n\n\n\n\n/***/ }),\n/* 36 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Case3Solver; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__models_RubiksCube__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__F2LCaseBaseSolver__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils__ = __webpack_require__(0);\n\n\n\n\nconst R = (moves) => __WEBPACK_IMPORTED_MODULE_0__models_RubiksCube__[\"a\" /* RubiksCube */].reverseMoves(moves);\n\n/**\n * Top level case 3:\n * Corner is on UP face and edge is on DOWN face.\n */\nclass Case3Solver extends __WEBPACK_IMPORTED_MODULE_1__F2LCaseBaseSolver__[\"a\" /* F2LCaseBaseSolver */] {\n\t/**\n   * 2 cases:\n   *\n   * 1) Corner's cross color is on the cross face.\n   * 2) Corner's cross color is not on the cross face.\n   */\n\t_getCaseNumber({ corner, edge }) {\n\t\tif (corner.getColorOfFace('up') === 'u') {\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\t_solveCase1({ corner, edge }) {\n\t\tlet faces = corner.faces().filter(face => face !== 'up');\n\t\tlet direction = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"c\" /* getDirectionFromFaces */])(faces[0], faces[1], { up: 'down' });\n\t\tlet [leftFace, rightFace] = direction === 'right' ? faces : faces.reverse();\n\n\t\tlet currentFace = edge.faces().find(face => face !== 'down');\n\t\tlet primaryColor = edge.getColorOfFace(currentFace);\n\n\t\tlet targetFace = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"e\" /* getFaceFromDirection */])(\n\t\t\tcorner.getFaceOfColor(primaryColor),\n\t\t\tprimaryColor === corner.getColorOfFace(rightFace) ? 'right' : 'left',\n\t\t\t{ up: 'down' }\n\t\t);\n\t\tlet isLeft = primaryColor === corner.getColorOfFace(leftFace);\n\n\t\tlet prep = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"b\" /* getRotationFromTo */])('down', currentFace, targetFace);\n\t\tlet moveFace = isLeft ? rightFace : R(leftFace);\n\t\tlet dir = isLeft ? 'DPrime' : 'D';\n\n\t\tthis.move(`${prep} ${moveFace} ${dir} ${R(moveFace)}`, { upperCase: true });\n\t\tthis.solveMatchedPair({ corner, edge });\n\t}\n\n\t_solveCase2({ corner, edge }) {\n\t\tlet otherColor = corner.colors().find(color => {\n\t\t\treturn color !== 'u' && corner.getFaceOfColor(color) !== 'up';\n\t\t});\n\t\tlet currentFace = edge.faces().find(face => face !== 'down');\n\t\tlet primaryColor = edge.getColorOfFace(currentFace);\n\n\t\tlet willBeMatched = otherColor !== primaryColor;\n\t\tlet targetFace = corner.getFaceOfColor(willBeMatched ? otherColor : 'u');\n\n\t\tlet prep = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"b\" /* getRotationFromTo */])('down', currentFace, targetFace);\n\t\tlet isLeft = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"c\" /* getDirectionFromFaces */])(\n\t\t\tcorner.getFaceOfColor(otherColor),\n\t\t\tcorner.getFaceOfColor('u'),\n\t\t\t{ up: 'down' }\n\t\t) === 'left';\n\t\tlet dir = isLeft ? 'DPrime' : 'D';\n\t\tlet moveFace = corner.getFaceOfColor('u');\n\t\tmoveFace = isLeft ? R(moveFace) : moveFace;\n\n\t\tthis.move(`${prep} ${moveFace} ${dir} ${R(moveFace)}`, { upperCase: true });\n\t\tlet solveFn = `solve${willBeMatched ? 'Matched' : 'Separated'}Pair`;\n\t\tthis[solveFn]({ corner, edge });\n\t}\n}\n\n\n\n\n/***/ })\n/******/ ]);\n});\n\n//# sourceURL=webpack:///./node_modules/rubiks-cube-solver/lib/index.es6.js?");

/***/ }),

/***/ "./src/js/index.js":
/*!*************************!*\
  !*** ./src/js/index.js ***!
  \*************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var rubiks_cube_solver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rubiks-cube-solver */ \"./node_modules/rubiks-cube-solver/lib/index.es6.js\");\n/* harmony import */ var rubiks_cube_solver__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rubiks_cube_solver__WEBPACK_IMPORTED_MODULE_0__);\n\n\nclass Demo {\n\tconstructor() {\n\t\tthis._onClick = this._onClick.bind(this);\n\n\t\tthis._button = document.querySelector('.button');\n\t\tthis._scrambleMoves = document.querySelector('.scramble-moves');\n\t\tthis._solveContainer = document.querySelector('.move-container-solve');\n\t\tthis._solveAltContainer = document.querySelector('.move-container-solve-alt');\n\n\t\tthis._button.addEventListener('click', this._onClick);\n\n\t\tthis._populateDemo();\n\t}\n\n\t_onClick() {\n\t\tthis._populateDemo();\n\t}\n\n\t_populateDemo() {\n\t\tconst scrambleMoves = rubiks_cube_solver__WEBPACK_IMPORTED_MODULE_0__[\"RubiksCube\"].getRandomMoves();\n\n\t\tconst cube = rubiks_cube_solver__WEBPACK_IMPORTED_MODULE_0__[\"RubiksCube\"].FromMoves(scrambleMoves);\n\t\tconst solveMoves = rubiks_cube_solver__WEBPACK_IMPORTED_MODULE_0___default()(cube.clone());\n\t\tconst partitions = rubiks_cube_solver__WEBPACK_IMPORTED_MODULE_0___default()(cube.clone(), { partitioned: true });\n\n\t\tthis._populateDemoScramble(scrambleMoves);\n\t\tthis._populateDemoSolve(solveMoves);\n\t\tthis._populateDemoPartitions(partitions);\n\t}\n\n\t_populateDemoScramble(scrambleMoves) {\n\t\tthis._scrambleMoves.textContent = this._getPrettyMoves(scrambleMoves);\n\t}\n\n\t_populateDemoSolve(solveMoves) {\n\t\tconst moves = this._solveContainer.querySelector('.moves');\n\t\tconst movesAlt = this._solveAltContainer.querySelector('.moves');\n\n\t\tmoves.textContent = this._getPrettyMoves(solveMoves);\n\t\tmovesAlt.textContent = this._getPrettyMoves(rubiks_cube_solver__WEBPACK_IMPORTED_MODULE_0__[\"RubiksCube\"].transformMoves(solveMoves, {\n\t\t\torientation: { front: 'front', down: 'up' }\n\t\t}));\n\t}\n\n\t_populateDemoPartitions(partitions) {\n\t\tconst partitionsEl = this._solveContainer.querySelector('.partitions');\n\t\tconst partitionsAltEl = this._solveAltContainer.querySelector('.partitions');\n\n\t\tfor (const phase of Object.keys(partitions)) {\n\t\t\tconst li = partitionsEl.querySelector(`.moves-${phase}`);\n\t\t\tconst liAlt = partitionsAltEl.querySelector(`.moves-${phase}`);\n\n\t\t\tconst moves = partitions[phase];\n\t\t\tconst transformed = Array.isArray(moves) ?\n\t\t\t\tmoves.map(moves => this._getTransformedMoves(moves)) :\n\t\t\t\tthis._getTransformedMoves(moves);\n\n\t\t\tli.textContent = this._getPrettyMoves(moves);\n\t\t\tliAlt.textContent = this._getPrettyMoves(transformed);\n\t\t}\n\t}\n\n\t_getTransformedMoves(moves) {\n\t\treturn rubiks_cube_solver__WEBPACK_IMPORTED_MODULE_0__[\"RubiksCube\"].transformMoves(moves, {\n\t\t\torientation: { front: 'front', down: 'up' }\n\t\t});\n\t}\n\n\t_getPrettyMoves(moves) {\n\t\t// if array, then it holds not an array of single moves, but an array of\n\t\t// a move group, and each group should be contained inside []\n\t\tif (Array.isArray(moves)) {\n\t\t\tmoves = moves.map(moveGroup => `[${moveGroup}]`).join(', ');\n\t\t}\n\n\t\treturn moves.replace(/prime/ig, '\\'');\n\t}\n}\n\nnew Demo();\n\n\n//# sourceURL=webpack:///./src/js/index.js?");

/***/ })

/******/ });